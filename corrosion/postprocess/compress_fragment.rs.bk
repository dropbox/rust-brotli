extern {
    fn BrotliBuildAndStoreHuffmanTreeFast(
        m : &mut [MemoryManager],
        histogram : & [u32],
        histogram_total : usize,
        max_bits : usize,
        depth : &mut [u8],
        bits : &mut [u16],
        storage_ix : &mut [usize],
        storage : &mut [u8
    ]);
    fn BrotliConvertBitDepthsToSymbols(
        depth : & [u8], len : usize, bits : &mut [u16
    ]);
    fn BrotliCreateHuffmanTree(
        data : & [u32],
        length : usize,
        tree_limit : i32,
        tree : &mut [HuffmanTree],
        depth : &mut [u8
    ]);
    fn BrotliStoreHuffmanTree(
        depths : & [u8],
        num : usize,
        tree : &mut [HuffmanTree],
        storage_ix : &mut [usize],
        storage : &mut [u8
    ]);
    fn __swbuf(arg1 : i32, arg2 : &mut [__sFILE]) -> i32;
    fn memcpy(
        __dst : &mut [::std::os::raw::c_void],
        __src : & [::std::os::raw::c_void],
        __n : usize
    ) -> *mut ::std::os::raw::c_void;
    fn memset(
        __b : &mut [::std::os::raw::c_void], __c : i32, __len : usize
    ) -> *mut ::std::os::raw::c_void;
}

enum __sFILEX {
}

static mut kLog2Table
    : [f64; 256]
    = [   0.0000000000000000f64,
          0.0000000000000000f64,
          1.0000000000000000f64,
          1.5849625007211563f64,
          2.0000000000000000f64,
          2.3219280948873622f64,
          2.5849625007211561f64,
          2.8073549220576042f64,
          3.0000000000000000f64,
          3.1699250014423126f64,
          3.3219280948873626f64,
          3.4594316186372978f64,
          3.5849625007211565f64,
          3.7004397181410922f64,
          3.8073549220576037f64,
          3.9068905956085187f64,
          4.0000000000000000f64,
          4.0874628412503400f64,
          4.1699250014423122f64,
          4.2479275134435852f64,
          4.3219280948873626f64,
          4.3923174227787607f64,
          4.4594316186372973f64,
          4.5235619560570131f64,
          4.5849625007211570f64,
          4.6438561897747244f64,
          4.7004397181410926f64,
          4.7548875021634691f64,
          4.8073549220576037f64,
          4.8579809951275728f64,
          4.9068905956085187f64,
          4.9541963103868758f64,
          5.0000000000000000f64,
          5.0443941193584534f64,
          5.0874628412503400f64,
          5.1292830169449664f64,
          5.1699250014423122f64,
          5.2094533656289501f64,
          5.2479275134435852f64,
          5.2854022188622487f64,
          5.3219280948873626f64,
          5.3575520046180838f64,
          5.3923174227787607f64,
          5.4262647547020979f64,
          5.4594316186372973f64,
          5.4918530963296748f64,
          5.5235619560570131f64,
          5.5545888516776376f64,
          5.5849625007211570f64,
          5.6147098441152083f64,
          5.6438561897747244f64,
          5.6724253419714961f64,
          5.7004397181410926f64,
          5.7279204545631996f64,
          5.7548875021634691f64,
          5.7813597135246599f64,
          5.8073549220576046f64,
          5.8328900141647422f64,
          5.8579809951275719f64,
          5.8826430493618416f64,
          5.9068905956085187f64,
          5.9307373375628867f64,
          5.9541963103868758f64,
          5.9772799234999168f64,
          6.0000000000000000f64,
          6.0223678130284544f64,
          6.0443941193584534f64,
          6.0660891904577721f64,
          6.0874628412503400f64,
          6.1085244567781700f64,
          6.1292830169449672f64,
          6.1497471195046822f64,
          6.1699250014423122f64,
          6.1898245588800176f64,
          6.2094533656289510f64,
          6.2288186904958804f64,
          6.2479275134435861f64,
          6.2667865406949019f64,
          6.2854022188622487f64,
          6.3037807481771031f64,
          6.3219280948873617f64,
          6.3398500028846252f64,
          6.3575520046180847f64,
          6.3750394313469254f64,
          6.3923174227787598f64,
          6.4093909361377026f64,
          6.4262647547020979f64,
          6.4429434958487288f64,
          6.4594316186372982f64,
          6.4757334309663976f64,
          6.4918530963296748f64,
          6.5077946401986964f64,
          6.5235619560570131f64,
          6.5391588111080319f64,
          6.5545888516776376f64,
          6.5698556083309478f64,
          6.5849625007211561f64,
          6.5999128421871278f64,
          6.6147098441152092f64,
          6.6293566200796095f64,
          6.6438561897747253f64,
          6.6582114827517955f64,
          6.6724253419714952f64,
          6.6865005271832185f64,
          6.7004397181410917f64,
          6.7142455176661224f64,
          6.7279204545631988f64,
          6.7414669864011465f64,
          6.7548875021634691f64,
          6.7681843247769260f64,
          6.7813597135246599f64,
          6.7944158663501062f64,
          6.8073549220576037f64,
          6.8201789624151887f64,
          6.8328900141647422f64,
          6.8454900509443757f64,
          6.8579809951275719f64,
          6.8703647195834048f64,
          6.8826430493618416f64,
          6.8948177633079437f64,
          6.9068905956085187f64,
          6.9188632372745955f64,
          6.9307373375628867f64,
          6.9425145053392399f64,
          6.9541963103868758f64,
          6.9657842846620879f64,
          6.9772799234999168f64,
          6.9886846867721664f64,
          7.0000000000000000f64,
          7.0112272554232540f64,
          7.0223678130284544f64,
          7.0334230015374501f64,
          7.0443941193584534f64,
          7.0552824355011898f64,
          7.0660891904577721f64,
          7.0768155970508317f64,
          7.0874628412503400f64,
          7.0980320829605272f64,
          7.1085244567781700f64,
          7.1189410727235076f64,
          7.1292830169449664f64,
          7.1395513523987937f64,
          7.1497471195046822f64,
          7.1598713367783891f64,
          7.1699250014423130f64,
          7.1799090900149345f64,
          7.1898245588800176f64,
          7.1996723448363644f64,
          7.2094533656289492f64,
          7.2191685204621621f64,
          7.2288186904958804f64,
          7.2384047393250794f64,
          7.2479275134435861f64,
          7.2573878426926521f64,
          7.2667865406949019f64,
          7.2761244052742384f64,
          7.2854022188622487f64,
          7.2946207488916270f64,
          7.3037807481771031f64,
          7.3128829552843557f64,
          7.3219280948873617f64,
          7.3309168781146177f64,
          7.3398500028846243f64,
          7.3487281542310781f64,
          7.3575520046180847f64,
          7.3663222142458151f64,
          7.3750394313469254f64,
          7.3837042924740528f64,
          7.3923174227787607f64,
          7.4008794362821844f64,
          7.4093909361377026f64,
          7.4178525148858991f64,
          7.4262647547020979f64,
          7.4346282276367255f64,
          7.4429434958487288f64,
          7.4512111118323299f64,
          7.4594316186372973f64,
          7.4676055500829976f64,
          7.4757334309663976f64,
          7.4838157772642564f64,
          7.4918530963296748f64,
          7.4998458870832057f64,
          7.5077946401986964f64,
          7.5156998382840436f64,
          7.5235619560570131f64,
          7.5313814605163119f64,
          7.5391588111080319f64,
          7.5468944598876373f64,
          7.5545888516776376f64,
          7.5622424242210728f64,
          7.5698556083309478f64,
          7.5774288280357487f64,
          7.5849625007211561f64,
          7.5924570372680806f64,
          7.5999128421871278f64,
          7.6073303137496113f64,
          7.6147098441152075f64,
          7.6220518194563764f64,
          7.6293566200796095f64,
          7.6366246205436488f64,
          7.6438561897747244f64,
          7.6510516911789290f64,
          7.6582114827517955f64,
          7.6653359171851765f64,
          7.6724253419714952f64,
          7.6794800995054464f64,
          7.6865005271832185f64,
          7.6934869574993252f64,
          7.7004397181410926f64,
          7.7073591320808825f64,
          7.7142455176661224f64,
          7.7210991887071856f64,
          7.7279204545631996f64,
          7.7347096202258392f64,
          7.7414669864011465f64,
          7.7481928495894596f64,
          7.7548875021634691f64,
          7.7615512324444795f64,
          7.7681843247769260f64,
          7.7747870596011737f64,
          7.7813597135246608f64,
          7.7879025593914317f64,
          7.7944158663501062f64,
          7.8008998999203047f64,
          7.8073549220576037f64,
          7.8137811912170374f64,
          7.8201789624151887f64,
          7.8265484872909159f64,
          7.8328900141647422f64,
          7.8392037880969445f64,
          7.8454900509443757f64,
          7.8517490414160571f64,
          7.8579809951275719f64,
          7.8641861446542798f64,
          7.8703647195834048f64,
          7.8765169465650002f64,
          7.8826430493618425f64,
          7.8887432488982601f64,
          7.8948177633079446f64,
          7.9008668079807496f64,
          7.9068905956085187f64,
          7.9128893362299619f64,
          7.9188632372745955f64,
          7.9248125036057813f64,
          7.9307373375628867f64,
          7.9366379390025719f64,
          7.9425145053392399f64,
          7.9483672315846778f64,
          7.9541963103868758f64,
          7.9600019320680806f64,
          7.9657842846620870f64,
          7.9715435539507720f64,
          7.9772799234999168f64,
          7.9829935746943104f64,
          7.9886846867721664f64,
          7.9943534368588578f64
      ];


pub fn log2(mut v : f64) -> f64 {
    if v < 0i32 as (f64) {
        0i32 as (f64)
    } else if v < 256i32 as (f64) {
        kLog2Table[v as (usize)]
    } else {
        let mut count : f64 = 0i32 as (f64);
        while 1i32 != 0 {
            v = v / 2i32 as (f64);
            count = count + 1.0f64;
            if v < 256i32 as (f64) {
                return kLog2Table[v as (usize)] + count;
            }
        }
    }
}

static mut kLog2Table
    : [f32; 256]
    = [   0.0000000000000000f32,
          0.0000000000000000f32,
          1.0000000000000000f32,
          1.5849625007211563f32,
          2.0000000000000000f32,
          2.3219280948873622f32,
          2.5849625007211561f32,
          2.8073549220576042f32,
          3.0000000000000000f32,
          3.1699250014423126f32,
          3.3219280948873626f32,
          3.4594316186372978f32,
          3.5849625007211565f32,
          3.7004397181410922f32,
          3.8073549220576037f32,
          3.9068905956085187f32,
          4.0000000000000000f32,
          4.0874628412503400f32,
          4.1699250014423122f32,
          4.2479275134435852f32,
          4.3219280948873626f32,
          4.3923174227787607f32,
          4.4594316186372973f32,
          4.5235619560570131f32,
          4.5849625007211570f32,
          4.6438561897747244f32,
          4.7004397181410926f32,
          4.7548875021634691f32,
          4.8073549220576037f32,
          4.8579809951275728f32,
          4.9068905956085187f32,
          4.9541963103868758f32,
          5.0000000000000000f32,
          5.0443941193584534f32,
          5.0874628412503400f32,
          5.1292830169449664f32,
          5.1699250014423122f32,
          5.2094533656289501f32,
          5.2479275134435852f32,
          5.2854022188622487f32,
          5.3219280948873626f32,
          5.3575520046180838f32,
          5.3923174227787607f32,
          5.4262647547020979f32,
          5.4594316186372973f32,
          5.4918530963296748f32,
          5.5235619560570131f32,
          5.5545888516776376f32,
          5.5849625007211570f32,
          5.6147098441152083f32,
          5.6438561897747244f32,
          5.6724253419714961f32,
          5.7004397181410926f32,
          5.7279204545631996f32,
          5.7548875021634691f32,
          5.7813597135246599f32,
          5.8073549220576046f32,
          5.8328900141647422f32,
          5.8579809951275719f32,
          5.8826430493618416f32,
          5.9068905956085187f32,
          5.9307373375628867f32,
          5.9541963103868758f32,
          5.9772799234999168f32,
          6.0000000000000000f32,
          6.0223678130284544f32,
          6.0443941193584534f32,
          6.0660891904577721f32,
          6.0874628412503400f32,
          6.1085244567781700f32,
          6.1292830169449672f32,
          6.1497471195046822f32,
          6.1699250014423122f32,
          6.1898245588800176f32,
          6.2094533656289510f32,
          6.2288186904958804f32,
          6.2479275134435861f32,
          6.2667865406949019f32,
          6.2854022188622487f32,
          6.3037807481771031f32,
          6.3219280948873617f32,
          6.3398500028846252f32,
          6.3575520046180847f32,
          6.3750394313469254f32,
          6.3923174227787598f32,
          6.4093909361377026f32,
          6.4262647547020979f32,
          6.4429434958487288f32,
          6.4594316186372982f32,
          6.4757334309663976f32,
          6.4918530963296748f32,
          6.5077946401986964f32,
          6.5235619560570131f32,
          6.5391588111080319f32,
          6.5545888516776376f32,
          6.5698556083309478f32,
          6.5849625007211561f32,
          6.5999128421871278f32,
          6.6147098441152092f32,
          6.6293566200796095f32,
          6.6438561897747253f32,
          6.6582114827517955f32,
          6.6724253419714952f32,
          6.6865005271832185f32,
          6.7004397181410917f32,
          6.7142455176661224f32,
          6.7279204545631988f32,
          6.7414669864011465f32,
          6.7548875021634691f32,
          6.7681843247769260f32,
          6.7813597135246599f32,
          6.7944158663501062f32,
          6.8073549220576037f32,
          6.8201789624151887f32,
          6.8328900141647422f32,
          6.8454900509443757f32,
          6.8579809951275719f32,
          6.8703647195834048f32,
          6.8826430493618416f32,
          6.8948177633079437f32,
          6.9068905956085187f32,
          6.9188632372745955f32,
          6.9307373375628867f32,
          6.9425145053392399f32,
          6.9541963103868758f32,
          6.9657842846620879f32,
          6.9772799234999168f32,
          6.9886846867721664f32,
          7.0000000000000000f32,
          7.0112272554232540f32,
          7.0223678130284544f32,
          7.0334230015374501f32,
          7.0443941193584534f32,
          7.0552824355011898f32,
          7.0660891904577721f32,
          7.0768155970508317f32,
          7.0874628412503400f32,
          7.0980320829605272f32,
          7.1085244567781700f32,
          7.1189410727235076f32,
          7.1292830169449664f32,
          7.1395513523987937f32,
          7.1497471195046822f32,
          7.1598713367783891f32,
          7.1699250014423130f32,
          7.1799090900149345f32,
          7.1898245588800176f32,
          7.1996723448363644f32,
          7.2094533656289492f32,
          7.2191685204621621f32,
          7.2288186904958804f32,
          7.2384047393250794f32,
          7.2479275134435861f32,
          7.2573878426926521f32,
          7.2667865406949019f32,
          7.2761244052742384f32,
          7.2854022188622487f32,
          7.2946207488916270f32,
          7.3037807481771031f32,
          7.3128829552843557f32,
          7.3219280948873617f32,
          7.3309168781146177f32,
          7.3398500028846243f32,
          7.3487281542310781f32,
          7.3575520046180847f32,
          7.3663222142458151f32,
          7.3750394313469254f32,
          7.3837042924740528f32,
          7.3923174227787607f32,
          7.4008794362821844f32,
          7.4093909361377026f32,
          7.4178525148858991f32,
          7.4262647547020979f32,
          7.4346282276367255f32,
          7.4429434958487288f32,
          7.4512111118323299f32,
          7.4594316186372973f32,
          7.4676055500829976f32,
          7.4757334309663976f32,
          7.4838157772642564f32,
          7.4918530963296748f32,
          7.4998458870832057f32,
          7.5077946401986964f32,
          7.5156998382840436f32,
          7.5235619560570131f32,
          7.5313814605163119f32,
          7.5391588111080319f32,
          7.5468944598876373f32,
          7.5545888516776376f32,
          7.5622424242210728f32,
          7.5698556083309478f32,
          7.5774288280357487f32,
          7.5849625007211561f32,
          7.5924570372680806f32,
          7.5999128421871278f32,
          7.6073303137496113f32,
          7.6147098441152075f32,
          7.6220518194563764f32,
          7.6293566200796095f32,
          7.6366246205436488f32,
          7.6438561897747244f32,
          7.6510516911789290f32,
          7.6582114827517955f32,
          7.6653359171851765f32,
          7.6724253419714952f32,
          7.6794800995054464f32,
          7.6865005271832185f32,
          7.6934869574993252f32,
          7.7004397181410926f32,
          7.7073591320808825f32,
          7.7142455176661224f32,
          7.7210991887071856f32,
          7.7279204545631996f32,
          7.7347096202258392f32,
          7.7414669864011465f32,
          7.7481928495894596f32,
          7.7548875021634691f32,
          7.7615512324444795f32,
          7.7681843247769260f32,
          7.7747870596011737f32,
          7.7813597135246608f32,
          7.7879025593914317f32,
          7.7944158663501062f32,
          7.8008998999203047f32,
          7.8073549220576037f32,
          7.8137811912170374f32,
          7.8201789624151887f32,
          7.8265484872909159f32,
          7.8328900141647422f32,
          7.8392037880969445f32,
          7.8454900509443757f32,
          7.8517490414160571f32,
          7.8579809951275719f32,
          7.8641861446542798f32,
          7.8703647195834048f32,
          7.8765169465650002f32,
          7.8826430493618425f32,
          7.8887432488982601f32,
          7.8948177633079446f32,
          7.9008668079807496f32,
          7.9068905956085187f32,
          7.9128893362299619f32,
          7.9188632372745955f32,
          7.9248125036057813f32,
          7.9307373375628867f32,
          7.9366379390025719f32,
          7.9425145053392399f32,
          7.9483672315846778f32,
          7.9541963103868758f32,
          7.9600019320680806f32,
          7.9657842846620870f32,
          7.9715435539507720f32,
          7.9772799234999168f32,
          7.9829935746943104f32,
          7.9886846867721664f32,
          7.9943534368588578f32
      ];

static mut kInsBase
    : [u32; 24]
    = [   0u32,
          1u32,
          2u32,
          3u32,
          4u32,
          5u32,
          6u32,
          8u32,
          10u32,
          14u32,
          18u32,
          26u32,
          34u32,
          50u32,
          66u32,
          98u32,
          130u32,
          194u32,
          322u32,
          578u32,
          1090u32,
          2114u32,
          6210u32,
          22594u32
      ];

static mut kInsExtra
    : [u32; 24]
    = [   0u32,
          0u32,
          0u32,
          0u32,
          0u32,
          0u32,
          1u32,
          1u32,
          2u32,
          2u32,
          3u32,
          3u32,
          4u32,
          4u32,
          5u32,
          5u32,
          6u32,
          7u32,
          8u32,
          9u32,
          10u32,
          12u32,
          14u32,
          24u32
      ];

static mut kCopyBase
    : [u32; 24]
    = [   2u32,
          3u32,
          4u32,
          5u32,
          6u32,
          7u32,
          8u32,
          9u32,
          10u32,
          12u32,
          14u32,
          18u32,
          22u32,
          30u32,
          38u32,
          54u32,
          70u32,
          102u32,
          134u32,
          198u32,
          326u32,
          582u32,
          1094u32,
          2118u32
      ];

static mut kCopyExtra
    : [u32; 24]
    = [   0u32,
          0u32,
          0u32,
          0u32,
          0u32,
          0u32,
          0u32,
          0u32,
          1u32,
          1u32,
          2u32,
          2u32,
          3u32,
          3u32,
          4u32,
          4u32,
          5u32,
          5u32,
          6u32,
          7u32,
          8u32,
          9u32,
          10u32,
          24u32
      ];

static mut kUTF8ContextLookup
    : [u8; 512]
    = [   0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          4i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          8i32 as (u8),
          12i32 as (u8),
          16i32 as (u8),
          12i32 as (u8),
          12i32 as (u8),
          20i32 as (u8),
          12i32 as (u8),
          16i32 as (u8),
          24i32 as (u8),
          28i32 as (u8),
          12i32 as (u8),
          12i32 as (u8),
          32i32 as (u8),
          12i32 as (u8),
          36i32 as (u8),
          12i32 as (u8),
          44i32 as (u8),
          44i32 as (u8),
          44i32 as (u8),
          44i32 as (u8),
          44i32 as (u8),
          44i32 as (u8),
          44i32 as (u8),
          44i32 as (u8),
          44i32 as (u8),
          44i32 as (u8),
          32i32 as (u8),
          32i32 as (u8),
          24i32 as (u8),
          40i32 as (u8),
          28i32 as (u8),
          12i32 as (u8),
          12i32 as (u8),
          48i32 as (u8),
          52i32 as (u8),
          52i32 as (u8),
          52i32 as (u8),
          48i32 as (u8),
          52i32 as (u8),
          52i32 as (u8),
          52i32 as (u8),
          48i32 as (u8),
          52i32 as (u8),
          52i32 as (u8),
          52i32 as (u8),
          52i32 as (u8),
          52i32 as (u8),
          48i32 as (u8),
          52i32 as (u8),
          52i32 as (u8),
          52i32 as (u8),
          52i32 as (u8),
          52i32 as (u8),
          48i32 as (u8),
          52i32 as (u8),
          52i32 as (u8),
          52i32 as (u8),
          52i32 as (u8),
          52i32 as (u8),
          24i32 as (u8),
          12i32 as (u8),
          28i32 as (u8),
          12i32 as (u8),
          12i32 as (u8),
          12i32 as (u8),
          56i32 as (u8),
          60i32 as (u8),
          60i32 as (u8),
          60i32 as (u8),
          56i32 as (u8),
          60i32 as (u8),
          60i32 as (u8),
          60i32 as (u8),
          56i32 as (u8),
          60i32 as (u8),
          60i32 as (u8),
          60i32 as (u8),
          60i32 as (u8),
          60i32 as (u8),
          56i32 as (u8),
          60i32 as (u8),
          60i32 as (u8),
          60i32 as (u8),
          60i32 as (u8),
          60i32 as (u8),
          56i32 as (u8),
          60i32 as (u8),
          60i32 as (u8),
          60i32 as (u8),
          60i32 as (u8),
          60i32 as (u8),
          24i32 as (u8),
          12i32 as (u8),
          28i32 as (u8),
          12i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          1i32 as (u8),
          0i32 as (u8),
          1i32 as (u8),
          0i32 as (u8),
          1i32 as (u8),
          0i32 as (u8),
          1i32 as (u8),
          0i32 as (u8),
          1i32 as (u8),
          0i32 as (u8),
          1i32 as (u8),
          0i32 as (u8),
          1i32 as (u8),
          0i32 as (u8),
          1i32 as (u8),
          0i32 as (u8),
          1i32 as (u8),
          0i32 as (u8),
          1i32 as (u8),
          0i32 as (u8),
          1i32 as (u8),
          0i32 as (u8),
          1i32 as (u8),
          0i32 as (u8),
          1i32 as (u8),
          0i32 as (u8),
          1i32 as (u8),
          0i32 as (u8),
          1i32 as (u8),
          0i32 as (u8),
          1i32 as (u8),
          0i32 as (u8),
          1i32 as (u8),
          0i32 as (u8),
          1i32 as (u8),
          0i32 as (u8),
          1i32 as (u8),
          0i32 as (u8),
          1i32 as (u8),
          0i32 as (u8),
          1i32 as (u8),
          0i32 as (u8),
          1i32 as (u8),
          0i32 as (u8),
          1i32 as (u8),
          0i32 as (u8),
          1i32 as (u8),
          0i32 as (u8),
          1i32 as (u8),
          0i32 as (u8),
          1i32 as (u8),
          0i32 as (u8),
          1i32 as (u8),
          0i32 as (u8),
          1i32 as (u8),
          0i32 as (u8),
          1i32 as (u8),
          0i32 as (u8),
          1i32 as (u8),
          0i32 as (u8),
          1i32 as (u8),
          0i32 as (u8),
          1i32 as (u8),
          2i32 as (u8),
          3i32 as (u8),
          2i32 as (u8),
          3i32 as (u8),
          2i32 as (u8),
          3i32 as (u8),
          2i32 as (u8),
          3i32 as (u8),
          2i32 as (u8),
          3i32 as (u8),
          2i32 as (u8),
          3i32 as (u8),
          2i32 as (u8),
          3i32 as (u8),
          2i32 as (u8),
          3i32 as (u8),
          2i32 as (u8),
          3i32 as (u8),
          2i32 as (u8),
          3i32 as (u8),
          2i32 as (u8),
          3i32 as (u8),
          2i32 as (u8),
          3i32 as (u8),
          2i32 as (u8),
          3i32 as (u8),
          2i32 as (u8),
          3i32 as (u8),
          2i32 as (u8),
          3i32 as (u8),
          2i32 as (u8),
          3i32 as (u8),
          2i32 as (u8),
          3i32 as (u8),
          2i32 as (u8),
          3i32 as (u8),
          2i32 as (u8),
          3i32 as (u8),
          2i32 as (u8),
          3i32 as (u8),
          2i32 as (u8),
          3i32 as (u8),
          2i32 as (u8),
          3i32 as (u8),
          2i32 as (u8),
          3i32 as (u8),
          2i32 as (u8),
          3i32 as (u8),
          2i32 as (u8),
          3i32 as (u8),
          2i32 as (u8),
          3i32 as (u8),
          2i32 as (u8),
          3i32 as (u8),
          2i32 as (u8),
          3i32 as (u8),
          2i32 as (u8),
          3i32 as (u8),
          2i32 as (u8),
          3i32 as (u8),
          2i32 as (u8),
          3i32 as (u8),
          2i32 as (u8),
          3i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8)
      ];

static mut kSigned3BitContextLookup
    : [u8; 256]
    = [   0i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          6i32 as (u8),
          6i32 as (u8),
          6i32 as (u8),
          6i32 as (u8),
          6i32 as (u8),
          6i32 as (u8),
          6i32 as (u8),
          6i32 as (u8),
          6i32 as (u8),
          6i32 as (u8),
          6i32 as (u8),
          6i32 as (u8),
          6i32 as (u8),
          6i32 as (u8),
          6i32 as (u8),
          7i32 as (u8)
      ];

static kBrotliMinWindowBits : i32 = 10i32;

static kBrotliMaxWindowBits : i32 = 24i32;



pub struct __sbuf {
    pub _base : *mut u8,
    pub _size : i32,
}



pub struct __sFILE {
    pub _p : *mut u8,
    pub _r : i32,
    pub _w : i32,
    pub _flags : i16,
    pub _file : i16,
    pub _bf : __sbuf,
    pub _lbfsize : i32,
    pub _cookie : *mut ::std::os::raw::c_void,
    pub _close : fn(*mut ::std::os::raw::c_void) -> i32,
    pub _read : fn(*mut ::std::os::raw::c_void, *mut u8, i32) -> i32,
    pub _seek : fn(*mut ::std::os::raw::c_void, isize, i32) -> isize,
    pub _write : fn(*mut ::std::os::raw::c_void, *const u8, i32) -> i32,
    pub _ub : __sbuf,
    pub _extra : *mut __sFILEX,
    pub _ur : i32,
    pub _ubuf : [u8; 3],
    pub _nbuf : [u8; 1],
    pub _lb : __sbuf,
    pub _blksize : i32,
    pub _offset : isize,
}


static kHashMul32 : u32 = 0x1e35a7bdu32;

static mut kCmdHistoSeed
    : [u32; 128]
    = [   0u32,
          1u32,
          1u32,
          1u32,
          1u32,
          1u32,
          1u32,
          1u32,
          1u32,
          1u32,
          1u32,
          1u32,
          1u32,
          1u32,
          1u32,
          1u32,
          0u32,
          0u32,
          0u32,
          1u32,
          1u32,
          1u32,
          1u32,
          1u32,
          1u32,
          1u32,
          1u32,
          1u32,
          1u32,
          1u32,
          1u32,
          1u32,
          1u32,
          1u32,
          1u32,
          1u32,
          1u32,
          1u32,
          1u32,
          1u32,
          0u32,
          1u32,
          1u32,
          1u32,
          1u32,
          1u32,
          1u32,
          1u32,
          1u32,
          1u32,
          1u32,
          1u32,
          1u32,
          1u32,
          1u32,
          1u32,
          1u32,
          1u32,
          1u32,
          1u32,
          1u32,
          1u32,
          1u32,
          1u32,
          1u32,
          0u32,
          0u32,
          0u32,
          0u32,
          0u32,
          0u32,
          0u32,
          0u32,
          0u32,
          0u32,
          0u32,
          0u32,
          0u32,
          0u32,
          0u32,
          1u32,
          1u32,
          1u32,
          1u32,
          1u32,
          1u32,
          1u32,
          1u32,
          1u32,
          1u32,
          1u32,
          1u32,
          1u32,
          1u32,
          1u32,
          1u32,
          1u32,
          1u32,
          1u32,
          1u32,
          1u32,
          1u32,
          1u32,
          1u32,
          1u32,
          1u32,
          1u32,
          1u32,
          1u32,
          1u32,
          1u32,
          1u32,
          1u32,
          1u32,
          1u32,
          1u32,
          1u32,
          1u32,
          1u32,
          1u32,
          1u32,
          1u32,
          1u32,
          1u32,
          0u32,
          0u32,
          0u32,
          0u32
      ];



pub struct MemoryManager {
    pub alloc_func : fn(*mut ::std::os::raw::c_void, usize) -> *mut ::std::os::raw::c_void,
    pub free_func : fn(*mut ::std::os::raw::c_void, *mut ::std::os::raw::c_void),
    pub opaque : *mut ::std::os::raw::c_void,
}

fn Log2FloorNonZero(mut n : usize) -> u32 {
    let mut result : u32 = 0u32;
    while {
              n = n >> 1i32;
              n
          } != 0 {
        result = result.wrapping_add(1 as (u32));
    }
    result
}

fn BROTLI_UNALIGNED_STORE64(
    mut p : &mut [::std::os::raw::c_void], mut v : usize
) {
    memcpy(
        p,
        &mut v  ,
        ::std::mem::size_of::<usize>()
    );
}

fn BrotliWriteBits(
    mut n_bits : usize,
    mut bits : usize,
    mut pos : &mut [usize],
    mut array : &mut [u8
]) {
    let mut p
        : *mut u8
        = &mut array[((*pos >> 3i32) as (usize)) ];
    let mut v : usize = *p as (usize);
    0i32;
    0i32;
    v = v | bits << (*pos & 7usize);
    BROTLI_UNALIGNED_STORE64(p ,v);
    *pos = (*pos).wrapping_add(n_bits);
}

fn brotli_min_size_t(
    mut a : usize, mut b : usize
) -> usize {
    if a < b { a } else { b }
}

fn BrotliStoreMetaBlockHeader(
    mut len : usize,
    mut is_uncompressed : i32,
    mut storage_ix : &mut [usize],
    mut storage : &mut [u8
]) {
    let mut nibbles : usize = 6usize;
    BrotliWriteBits(
        1usize,
        0usize,
        storage_ix,
        storage
    );
    if len <= (1u32 << 16i32) as (usize) {
        nibbles = 4usize;
    } else if len <= (1u32 << 20i32) as (usize) {
        nibbles = 5usize;
    }
    BrotliWriteBits(
        2usize,
        nibbles.wrapping_sub(4usize),
        storage_ix,
        storage
    );
    BrotliWriteBits(
        nibbles.wrapping_mul(4usize),
        len.wrapping_sub(1usize),
        storage_ix,
        storage
    );
    BrotliWriteBits(
        1usize,
        is_uncompressed as (usize),
        storage_ix,
        storage
    );
}

fn brotli_min_uint32_t(
    mut a : u32, mut b : u32
) -> u32 {
    if a < b { a } else { b }
}

fn BuildAndStoreLiteralPrefixCode(
    mut m : &mut [MemoryManager],
    mut input : & [u8],
    input_size : usize,
    mut depths : &mut [u8],
    mut bits : &mut [u16],
    mut storage_ix : &mut [usize],
    mut storage : &mut [u8
]) -> usize {
    let mut histogram
        : [u32; 256]
        = [   0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32,
              0u32
          ];
    let mut histogram_total : usize;
    let mut i : usize;
    if input_size < (1i32 << 15i32) as (usize) {
        i = 0usize;
        while i < input_size {
            {
                let _rhs = 1;
                let _lhs = &mut histogram[input[(i as (usize)) ]as (usize)];
                *_lhs = (*_lhs).wrapping_add(_rhs as (u32));
            }
            i = i.wrapping_add(1 as (usize));
        }
        histogram_total = input_size;
        i = 0usize;
        while i < 256usize {
            {
                let adjust
                    : u32
                    = (2u32).wrapping_mul(
                          brotli_min_uint32_t(histogram[i],11u32)
                      );
                {
                    let _rhs = adjust;
                    let _lhs = &mut histogram[i];
                    *_lhs = (*_lhs).wrapping_add(_rhs);
                }
                histogram_total = histogram_total.wrapping_add(adjust as (usize));
            }
            i = i.wrapping_add(1 as (usize));
        }
    } else {
        static kSampleRate : usize = 29usize;
        i = 0usize;
        while i < input_size {
            {
                let _rhs = 1;
                let _lhs = &mut histogram[input[(i as (usize)) ]as (usize)];
                *_lhs = (*_lhs).wrapping_add(_rhs as (u32));
            }
            i = i.wrapping_add(kSampleRate);
        }
        histogram_total = input_size.wrapping_add(
                              kSampleRate
                          ).wrapping_sub(
                              1usize
                          ).wrapping_div(
                              kSampleRate
                          );
        i = 0usize;
        while i < 256usize {
            {
                let adjust
                    : u32
                    = (1u32).wrapping_add(
                          (2u32).wrapping_mul(
                              brotli_min_uint32_t(histogram[i],11u32)
                          )
                      );
                {
                    let _rhs = adjust;
                    let _lhs = &mut histogram[i];
                    *_lhs = (*_lhs).wrapping_add(_rhs);
                }
                histogram_total = histogram_total.wrapping_add(adjust as (usize));
            }
            i = i.wrapping_add(1 as (usize));
        }
    }
    BrotliBuildAndStoreHuffmanTreeFast(
        m,
        histogram.as_mut_ptr() ,
        histogram_total,
        8usize,
        depths,
        bits,
        storage_ix,
        storage
    );
    if !(0i32 == 0) {
        return 0usize;
    }
    {
        let mut literal_ratio : usize = 0usize;
        i = 0usize;
        while i < 256usize {
            {
                if histogram[i] != 0 {
                    literal_ratio = literal_ratio.wrapping_add(
                                        histogram[i].wrapping_mul(
                                            depths[(i as (usize)) ]as (u32)
                                        ) as (usize)
                                    );
                }
            }
            i = i.wrapping_add(1 as (usize));
        }
        literal_ratio.wrapping_mul(125usize).wrapping_div(
            histogram_total
        )
    }
}


#[repr(i32)]
pub enum CodeBlockState {
    EMIT_REMAINDER,
    EMIT_COMMANDS,
    NEXT_BLOCK,
}

fn BROTLI_UNALIGNED_LOAD64(
    mut p : & [::std::os::raw::c_void
]) -> usize {
    let mut t : usize;
    memcpy(
        &mut t  ,
        p,
        ::std::mem::size_of::<usize>()
    );
    t
}

fn Hash(
    mut p : & [u8], mut shift : usize
) -> u32 {
    let h
        : usize
        = (BROTLI_UNALIGNED_LOAD64(
               p 
           ) << 24i32).wrapping_mul(
              kHashMul32 as (usize)
          );
    (h >> shift) as (u32)
}

fn BROTLI_UNALIGNED_LOAD32(
    mut p : & [::std::os::raw::c_void
]) -> u32 {
    let mut t : u32;
    memcpy(
        &mut t  ,
        p,
        ::std::mem::size_of::<u32>()
    );
    t
}

fn IsMatch(
    mut p1 : & [u8], mut p2 : & [u8
]) -> i32 {
    if !!(BROTLI_UNALIGNED_LOAD32(
              p1 
          ) == BROTLI_UNALIGNED_LOAD32(
                   p2 
               ) && (p1[(4usize) ]as (i32) == p2[(
                                                                  4usize
                                                              ) ]as (i32))) {
        1i32
    } else {
        0i32
    }
}

fn unopt_ctzll(mut val : usize) -> u8 {
    let mut cnt : u8 = 0i32 as (u8);
    while val & 1usize == 0usize {
        val = val >> 1i32;
        cnt = (cnt as (i32) + 1) as (u8);
    }
    cnt
}

fn FindMatchLengthWithLimit(
    mut s1 : & [u8], mut s2 : & [u8], mut limit : usize
) -> usize {
    let mut matched : usize = 0usize;
    let mut limit2
        : usize
        = (limit >> 3i32).wrapping_add(1usize);
    while {
              limit2 = limit2.wrapping_sub(1 as (usize));
              limit2
          } != 0 {
        if BROTLI_UNALIGNED_LOAD64(
               s2 
           ) == BROTLI_UNALIGNED_LOAD64(
                    s1[(matched as (usize)) ..]
                ) {
            s2 = s2[(8usize)..];
            matched = matched.wrapping_add(8usize);
        } else {
            let mut x
                : usize
                = BROTLI_UNALIGNED_LOAD64(
                      s2 
                  ) ^ BROTLI_UNALIGNED_LOAD64(
                          s1[(matched as (usize)) ..]
                      );
            let mut matching_bits : usize = unopt_ctzll(x) as (usize);
            matched = matched.wrapping_add(matching_bits >> 3i32);
            return matched;
        }
    }
    limit = (limit & 7usize).wrapping_add(1usize);
    while {
              limit = limit.wrapping_sub(1 as (usize));
              limit
          } != 0 {
        if s1[(matched as (usize)) ]as (i32) == *s2 as (i32) {
            s2 = s2[(1 as (usize))..];
            matched = matched.wrapping_add(1 as (usize));
        } else {
            return matched;
        }
    }
    matched
}

fn EmitInsertLen(
    mut insertlen : usize,
    mut depth : & [u8],
    mut bits : & [u16],
    mut histo : &mut [u32],
    mut storage_ix : &mut [usize],
    mut storage : &mut [u8
]) { if insertlen < 6usize {
        let code : usize = insertlen.wrapping_add(40usize);
        BrotliWriteBits(
            depth[(code as (usize)) ]as (usize),
            bits[(code as (usize)) ]as (usize),
            storage_ix,
            storage
        );
        {
            let _rhs = 1;
            let _lhs = &mut histo[(code as (usize))];
            *_lhs = (*_lhs).wrapping_add(_rhs as (u32));
        }
    } else if insertlen < 130usize {
        let tail : usize = insertlen.wrapping_sub(2usize);
        let nbits : u32 = Log2FloorNonZero(tail).wrapping_sub(1u32);
        let prefix : usize = tail >> nbits;
        let inscode
            : usize
            = ((nbits << 1i32) as (usize)).wrapping_add(prefix).wrapping_add(
                  42usize
              );
        BrotliWriteBits(
            depth[(inscode as (usize)) ]as (usize),
            bits[(inscode as (usize)) ]as (usize),
            storage_ix,
            storage
        );
        BrotliWriteBits(
            nbits as (usize),
            tail.wrapping_sub(prefix << nbits),
            storage_ix,
            storage
        );
        {
            let _rhs = 1;
            let _lhs = &mut histo[(inscode as (usize))];
            *_lhs = (*_lhs).wrapping_add(_rhs as (u32));
        }
    } else if insertlen < 2114usize {
        let tail : usize = insertlen.wrapping_sub(66usize);
        let nbits : u32 = Log2FloorNonZero(tail);
        let code : usize = nbits.wrapping_add(50u32) as (usize);
        BrotliWriteBits(
            depth[(code as (usize)) ]as (usize),
            bits[(code as (usize)) ]as (usize),
            storage_ix,
            storage
        );
        BrotliWriteBits(
            nbits as (usize),
            tail.wrapping_sub(1usize << nbits),
            storage_ix,
            storage
        );
        {
            let _rhs = 1;
            let _lhs = &mut histo[(code as (usize))];
            *_lhs = (*_lhs).wrapping_add(_rhs as (u32));
        }
    } else {
        BrotliWriteBits(
            depth[(61usize) ]as (usize),
            bits[(61usize) ]as (usize),
            storage_ix,
            storage
        );
        BrotliWriteBits(
            12usize,
            insertlen.wrapping_sub(2114usize),
            storage_ix,
            storage
        );
        {
            let _rhs = 1;
            let _lhs = &mut histo[(21usize)];
            *_lhs = (*_lhs).wrapping_add(_rhs as (u32));
        }
    }
}

fn ShouldUseUncompressedMode(
    mut metablock_start : & [u8],
    mut next_emit : & [u8],
    insertlen : usize,
    literal_ratio : usize
) -> i32 {
    let compressed
        : usize
        = ((next_emit as (isize)).wrapping_sub(
               metablock_start as (isize)
           ) / ::std::mem::size_of::<*const u8>() as (isize)) as (usize);
    if compressed.wrapping_mul(50usize) > insertlen {
        0i32
    } else if !!(literal_ratio > 980usize) {
        1i32
    } else {
        0i32
    }
}

fn RewindBitPosition(
    new_storage_ix : usize,
    mut storage_ix : &mut [usize],
    mut storage : &mut [u8
]) {
    let bitpos : usize = new_storage_ix & 7usize;
    let mask
        : usize
        = (1u32 << bitpos).wrapping_sub(1u32) as (usize);
    {
        let _rhs = mask as (u8);
        let _lhs
            = &mut storage[((new_storage_ix >> 3i32) as (usize))];
        *_lhs = (*_lhs as (i32) & _rhs as (i32)) as (u8);
    }
    *storage_ix = new_storage_ix;
}

fn EmitUncompressedMetaBlock(
    mut begin : & [u8],
    mut len : usize,
    storage_ix_start : usize,
    mut storage_ix : &mut [usize],
    mut storage : &mut [u8
]) {
    RewindBitPosition(storage_ix_start,storage_ix,storage);
    BrotliStoreMetaBlockHeader(len,1i32,storage_ix,storage);
    *storage_ix = (*storage_ix).wrapping_add(
                      7u32 as (usize)
                  ) & !7u32 as (usize);
    memcpy(
        &mut storage[(
                  (*storage_ix >> 3i32) as (usize)
              ) ] ,
        begin ,
        len
    );
    *storage_ix = (*storage_ix).wrapping_add(len << 3i32);
    storage[((*storage_ix >> 3i32) as (usize)) ]= 0i32 as (u8);
}

fn EmitLongInsertLen(
    mut insertlen : usize,
    mut depth : & [u8],
    mut bits : & [u16],
    mut histo : &mut [u32],
    mut storage_ix : &mut [usize],
    mut storage : &mut [u8
]) { if insertlen < 22594usize {
        BrotliWriteBits(
            depth[(62usize) ]as (usize),
            bits[(62usize) ]as (usize),
            storage_ix,
            storage
        );
        BrotliWriteBits(
            14usize,
            insertlen.wrapping_sub(6210usize),
            storage_ix,
            storage
        );
        {
            let _rhs = 1;
            let _lhs = &mut histo[(22usize)];
            *_lhs = (*_lhs).wrapping_add(_rhs as (u32));
        }
    } else {
        BrotliWriteBits(
            depth[(63usize) ]as (usize),
            bits[(63usize) ]as (usize),
            storage_ix,
            storage
        );
        BrotliWriteBits(
            24usize,
            insertlen.wrapping_sub(22594usize),
            storage_ix,
            storage
        );
        {
            let _rhs = 1;
            let _lhs = &mut histo[(23usize)];
            *_lhs = (*_lhs).wrapping_add(_rhs as (u32));
        }
    }
}

fn EmitLiterals(
    mut input : & [u8],
    len : usize,
    mut depth : & [u8],
    mut bits : & [u16],
    mut storage_ix : &mut [usize],
    mut storage : &mut [u8
]) {
    let mut j : usize;
    j = 0usize;
    while j < len {
        {
            let lit : u8 = input[(j as (usize))];
            BrotliWriteBits(
                depth[(lit as (usize)) ]as (usize),
                bits[(lit as (usize)) ]as (usize),
                storage_ix,
                storage
            );
        }
        j = j.wrapping_add(1 as (usize));
    }
}

fn EmitDistance(
    mut distance : usize,
    mut depth : & [u8],
    mut bits : & [u16],
    mut histo : &mut [u32],
    mut storage_ix : &mut [usize],
    mut storage : &mut [u8
]) {
    let d : usize = distance.wrapping_add(3usize);
    let nbits : u32 = Log2FloorNonZero(d).wrapping_sub(1u32);
    let prefix : usize = d >> nbits & 1usize;
    let offset
        : usize
        = (2usize).wrapping_add(prefix) << nbits;
    let distcode
        : usize
        = ((2u32).wrapping_mul(
               nbits.wrapping_sub(1u32)
           ) as (usize)).wrapping_add(
              prefix
          ).wrapping_add(
              80usize
          );
    BrotliWriteBits(
        depth[(distcode as (usize)) ]as (usize),
        bits[(distcode as (usize)) ]as (usize),
        storage_ix,
        storage
    );
    BrotliWriteBits(
        nbits as (usize),
        d.wrapping_sub(offset),
        storage_ix,
        storage
    );
    {
        let _rhs = 1;
        let _lhs = &mut histo[(distcode as (usize))];
        *_lhs = (*_lhs).wrapping_add(_rhs as (u32));
    }
}

fn EmitCopyLenLastDistance(
    mut copylen : usize,
    mut depth : & [u8],
    mut bits : & [u16],
    mut histo : &mut [u32],
    mut storage_ix : &mut [usize],
    mut storage : &mut [u8
]) { if copylen < 12usize {
        BrotliWriteBits(
            depth[(
                 copylen.wrapping_sub(4usize) as (usize)
             ) ]as (usize),
            bits[(
                 copylen.wrapping_sub(4usize) as (usize)
             ) ]as (usize),
            storage_ix,
            storage
        );
        {
            let _rhs = 1;
            let _lhs
                = &mut histo[(
                            copylen.wrapping_sub(4usize) as (usize)
                        )];
            *_lhs = (*_lhs).wrapping_add(_rhs as (u32));
        }
    } else if copylen < 72usize {
        let tail : usize = copylen.wrapping_sub(8usize);
        let nbits
            : u32
            = Log2FloorNonZero(tail).wrapping_sub(1u32);
        let prefix : usize = tail >> nbits;
        let code
            : usize
            = ((nbits << 1i32) as (usize)).wrapping_add(prefix).wrapping_add(
                  4usize
              );
        BrotliWriteBits(
            depth[(code as (usize)) ]as (usize),
            bits[(code as (usize)) ]as (usize),
            storage_ix,
            storage
        );
        BrotliWriteBits(
            nbits as (usize),
            tail.wrapping_sub(prefix << nbits),
            storage_ix,
            storage
        );
        {
            let _rhs = 1;
            let _lhs = &mut histo[(code as (usize))];
            *_lhs = (*_lhs).wrapping_add(_rhs as (u32));
        }
    } else if copylen < 136usize {
        let tail : usize = copylen.wrapping_sub(8usize);
        let code : usize = (tail >> 5i32).wrapping_add(30usize);
        BrotliWriteBits(
            depth[(code as (usize)) ]as (usize),
            bits[(code as (usize)) ]as (usize),
            storage_ix,
            storage
        );
        BrotliWriteBits(
            5usize,
            tail & 31usize,
            storage_ix,
            storage
        );
        BrotliWriteBits(
            depth[(64usize) ]as (usize),
            bits[(64usize) ]as (usize),
            storage_ix,
            storage
        );
        {
            let _rhs = 1;
            let _lhs = &mut histo[(code as (usize))];
            *_lhs = (*_lhs).wrapping_add(_rhs as (u32));
        }
        {
            let _rhs = 1;
            let _lhs = &mut histo[(64usize)];
            *_lhs = (*_lhs).wrapping_add(_rhs as (u32));
        }
    } else if copylen < 2120usize {
        let tail : usize = copylen.wrapping_sub(72usize);
        let nbits : u32 = Log2FloorNonZero(tail);
        let code : usize = nbits.wrapping_add(28u32) as (usize);
        BrotliWriteBits(
            depth[(code as (usize)) ]as (usize),
            bits[(code as (usize)) ]as (usize),
            storage_ix,
            storage
        );
        BrotliWriteBits(
            nbits as (usize),
            tail.wrapping_sub(1usize << nbits),
            storage_ix,
            storage
        );
        BrotliWriteBits(
            depth[(64usize) ]as (usize),
            bits[(64usize) ]as (usize),
            storage_ix,
            storage
        );
        {
            let _rhs = 1;
            let _lhs = &mut histo[(code as (usize))];
            *_lhs = (*_lhs).wrapping_add(_rhs as (u32));
        }
        {
            let _rhs = 1;
            let _lhs = &mut histo[(64usize)];
            *_lhs = (*_lhs).wrapping_add(_rhs as (u32));
        }
    } else {
        BrotliWriteBits(
            depth[(39usize) ]as (usize),
            bits[(39usize) ]as (usize),
            storage_ix,
            storage
        );
        BrotliWriteBits(
            24usize,
            copylen.wrapping_sub(2120usize),
            storage_ix,
            storage
        );
        BrotliWriteBits(
            depth[(64usize) ]as (usize),
            bits[(64usize) ]as (usize),
            storage_ix,
            storage
        );
        {
            let _rhs = 1;
            let _lhs = &mut histo[(47usize)];
            *_lhs = (*_lhs).wrapping_add(_rhs as (u32));
        }
        {
            let _rhs = 1;
            let _lhs = &mut histo[(64usize)];
            *_lhs = (*_lhs).wrapping_add(_rhs as (u32));
        }
    }
}

fn HashBytesAtOffset(
    mut v : usize, mut offset : i32, mut shift : usize
) -> u32 {
    0i32;
    0i32;
    {
        let h
            : usize
            = (v >> 8i32 * offset << 24i32).wrapping_mul(
                  kHashMul32 as (usize)
              );
        (h >> shift) as (u32)
    }
}

fn EmitCopyLen(
    mut copylen : usize,
    mut depth : & [u8],
    mut bits : & [u16],
    mut histo : &mut [u32],
    mut storage_ix : &mut [usize],
    mut storage : &mut [u8
]) { if copylen < 10usize {
        BrotliWriteBits(
            depth[(
                 copylen.wrapping_add(14usize) as (usize)
             ) ]as (usize),
            bits[(
                 copylen.wrapping_add(14usize) as (usize)
             ) ]as (usize),
            storage_ix,
            storage
        );
        {
            let _rhs = 1;
            let _lhs
                = &mut histo[(
                            copylen.wrapping_add(14usize) as (usize)
                        )];
            *_lhs = (*_lhs).wrapping_add(_rhs as (u32));
        }
    } else if copylen < 134usize {
        let tail : usize = copylen.wrapping_sub(6usize);
        let nbits : u32 = Log2FloorNonZero(tail).wrapping_sub(1u32);
        let prefix : usize = tail >> nbits;
        let code
            : usize
            = ((nbits << 1i32) as (usize)).wrapping_add(prefix).wrapping_add(
                  20usize
              );
        BrotliWriteBits(
            depth[(code as (usize)) ]as (usize),
            bits[(code as (usize)) ]as (usize),
            storage_ix,
            storage
        );
        BrotliWriteBits(
            nbits as (usize),
            tail.wrapping_sub(prefix << nbits),
            storage_ix,
            storage
        );
        {
            let _rhs = 1;
            let _lhs = &mut histo[(code as (usize))];
            *_lhs = (*_lhs).wrapping_add(_rhs as (u32));
        }
    } else if copylen < 2118usize {
        let tail : usize = copylen.wrapping_sub(70usize);
        let nbits : u32 = Log2FloorNonZero(tail);
        let code : usize = nbits.wrapping_add(28u32) as (usize);
        BrotliWriteBits(
            depth[(code as (usize)) ]as (usize),
            bits[(code as (usize)) ]as (usize),
            storage_ix,
            storage
        );
        BrotliWriteBits(
            nbits as (usize),
            tail.wrapping_sub(1usize << nbits),
            storage_ix,
            storage
        );
        {
            let _rhs = 1;
            let _lhs = &mut histo[(code as (usize))];
            *_lhs = (*_lhs).wrapping_add(_rhs as (u32));
        }
    } else {
        BrotliWriteBits(
            depth[(39usize) ]as (usize),
            bits[(39usize) ]as (usize),
            storage_ix,
            storage
        );
        BrotliWriteBits(
            24usize,
            copylen.wrapping_sub(2118usize),
            storage_ix,
            storage
        );
        {
            let _rhs = 1;
            let _lhs = &mut histo[(47usize)];
            *_lhs = (*_lhs).wrapping_add(_rhs as (u32));
        }
    }
}

fn FastLog2(mut v : usize) -> f64 {
    if v < ::std::mem::size_of::<[f32; 256]>().wrapping_div(
               ::std::mem::size_of::<f32>()
           ) {
        return kLog2Table[v] as (f64);
    }
    log2(v as (f64))
}

fn ShouldMergeBlock(
    mut data : & [u8], mut len : usize, mut depths : & [u8
]) -> i32 {
    let mut histo
        : [usize; 256]
        = [   0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize,
              0usize
          ];
    static kSampleRate : usize = 43usize;
    let mut i : usize;
    i = 0usize;
    while i < len {
        {
            let _rhs = 1;
            let _lhs = &mut histo[data[(i as (usize)) ]as (usize)];
            *_lhs = (*_lhs).wrapping_add(_rhs as (usize));
        }
        i = i.wrapping_add(kSampleRate);
    }
    {
        let total
            : usize
            = len.wrapping_add(kSampleRate).wrapping_sub(
                  1usize
              ).wrapping_div(
                  kSampleRate
              );
        let mut r
            : f64
            = (FastLog2(total) + 0.5f64) * total as (f64) + 200i32 as (f64);
        i = 0usize;
        while i < 256usize {
            {
                r = r - histo[i] as (f64) * (depths[(
                                                  i as (usize)
                                              ) ]as (f64) + FastLog2(histo[i]));
            }
            i = i.wrapping_add(1 as (usize));
        }
        if !!(r >= 0.0f64) { 1i32 } else { 0i32 }
    }
}

fn UpdateBits(
    mut n_bits : usize,
    mut bits : u32,
    mut pos : usize,
    mut array : &mut [u8
]) {
    while n_bits > 0usize {
        let mut byte_pos : usize = pos >> 3i32;
        let mut n_unchanged_bits : usize = pos & 7usize;
        let mut n_changed_bits
            : usize
            = brotli_min_size_t(
                  n_bits,
                  (8usize).wrapping_sub(n_unchanged_bits)
              );
        let mut total_bits
            : usize
            = n_unchanged_bits.wrapping_add(n_changed_bits);
        let mut mask
            : u32
            = !(1u32 << total_bits).wrapping_sub(
                   1u32
               ) | (1u32 << n_unchanged_bits).wrapping_sub(1u32);
        let mut unchanged_bits
            : u32
            = array[(byte_pos as (usize)) ]as (u32) & mask;
        let mut changed_bits
            : u32
            = bits & (1u32 << n_changed_bits).wrapping_sub(1u32);
        array[(
             byte_pos as (usize)
         ) ]= (changed_bits << n_unchanged_bits | unchanged_bits) as (u8);
        n_bits = n_bits.wrapping_sub(n_changed_bits);
        bits = bits >> n_changed_bits;
        pos = pos.wrapping_add(n_changed_bits);
    }
}



pub struct HuffmanTree {
    pub total_count_ : u32,
    pub index_left_ : i16,
    pub index_right_or_value_ : i16,
}

fn BuildAndStoreCommandPrefixCode(
    mut histogram : & [u32],
    mut depth : &mut [u8],
    mut bits : &mut [u16],
    mut storage_ix : &mut [usize],
    mut storage : &mut [u8
]) {
    let mut tree : [HuffmanTree; 129];
    let mut cmd_depth
        : [u8; 704]
        = [   0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8),
              0i32 as (u8)
          ];
    let mut cmd_bits : [u16; 64];
    BrotliCreateHuffmanTree(
        histogram,
        64usize,
        15i32,
        tree.as_mut_ptr(),
        depth
    );
    BrotliCreateHuffmanTree(
        &histogram[(64usize) ],
        64usize,
        14i32,
        tree.as_mut_ptr(),
        &mut depth[(64usize) ]
    );
    memcpy(
        cmd_depth.as_mut_ptr() ,
        depth ,
        24usize
    );
    memcpy(
        cmd_depth.as_mut_ptr().offset(
            24i32 as (isize)
        ) ,
        depth[(40usize) ..],
        8usize
    );
    memcpy(
        cmd_depth.as_mut_ptr().offset(
            32i32 as (isize)
        ) ,
        depth[(24usize) ..],
        8usize
    );
    memcpy(
        cmd_depth.as_mut_ptr().offset(
            40i32 as (isize)
        ) ,
        depth[(48usize) ..],
        8usize
    );
    memcpy(
        cmd_depth.as_mut_ptr().offset(
            48i32 as (isize)
        ) ,
        depth[(32usize) ..],
        8usize
    );
    memcpy(
        cmd_depth.as_mut_ptr().offset(
            56i32 as (isize)
        ) ,
        depth[(56usize) ..],
        8usize
    );
    BrotliConvertBitDepthsToSymbols(
        cmd_depth.as_mut_ptr() ,
        64usize,
        cmd_bits.as_mut_ptr()
    );
    memcpy(
        bits ,
        cmd_bits.as_mut_ptr() ,
        48usize
    );
    memcpy(
        bits[(24usize) ..],
        cmd_bits.as_mut_ptr().offset(
            32i32 as (isize)
        ) ,
        16usize
    );
    memcpy(
        bits[(32usize) ..],
        cmd_bits.as_mut_ptr().offset(
            48i32 as (isize)
        ) ,
        16usize
    );
    memcpy(
        bits[(40usize) ..],
        cmd_bits.as_mut_ptr().offset(
            24i32 as (isize)
        ) ,
        16usize
    );
    memcpy(
        bits[(48usize) ..],
        cmd_bits.as_mut_ptr().offset(
            40i32 as (isize)
        ) ,
        16usize
    );
    memcpy(
        bits[(56usize) ..],
        cmd_bits.as_mut_ptr().offset(
            56i32 as (isize)
        ) ,
        16usize
    );
    BrotliConvertBitDepthsToSymbols(
        &mut depth[(64usize) ] ,
        64usize,
        &mut bits[(64usize) ]
    );
    {
        let mut i : usize;
        memset(
            cmd_depth.as_mut_ptr() ,
            0i32,
            64usize
        );
        memcpy(
            cmd_depth.as_mut_ptr() ,
            depth ,
            8usize
        );
        memcpy(
            cmd_depth.as_mut_ptr().offset(
                64i32 as (isize)
            ) ,
            depth[(8usize) ..],
            8usize
        );
        memcpy(
            cmd_depth.as_mut_ptr().offset(
                128i32 as (isize)
            ) ,
            depth[(16usize) ..],
            8usize
        );
        memcpy(
            cmd_depth.as_mut_ptr().offset(
                192i32 as (isize)
            ) ,
            depth[(24usize) ..],
            8usize
        );
        memcpy(
            cmd_depth.as_mut_ptr().offset(
                384i32 as (isize)
            ) ,
            depth[(32usize) ..],
            8usize
        );
        i = 0usize;
        while i < 8usize {
            {
                cmd_depth[
                    (128usize).wrapping_add((8usize).wrapping_mul(i))
                ] = depth[((40usize).wrapping_add(i) as (usize))];
                cmd_depth[
                    (256usize).wrapping_add((8usize).wrapping_mul(i))
                ] = depth[((48usize).wrapping_add(i) as (usize))];
                cmd_depth[
                    (448usize).wrapping_add((8usize).wrapping_mul(i))
                ] = depth[((56usize).wrapping_add(i) as (usize))];
            }
            i = i.wrapping_add(1 as (usize));
        }
        BrotliStoreHuffmanTree(
            cmd_depth.as_mut_ptr() ,
            704usize,
            tree.as_mut_ptr(),
            storage_ix,
            storage
        );
    }
    BrotliStoreHuffmanTree(
        &mut depth[(64usize) ] ,
        64usize,
        tree.as_mut_ptr(),
        storage_ix,
        storage
    );
}

fn BrotliCompressFragmentFastImpl(
    mut m : &mut [MemoryManager],
    mut input_ptr : & [u8],
    mut input_size : usize,
    mut is_last : i32,
    mut table : &mut [i32],
    mut table_bits : usize,
    mut cmd_depth : &mut [u8],
    mut cmd_bits : &mut [u16],
    mut cmd_code_numbits : &mut [usize],
    mut cmd_code : &mut [u8],
    mut storage_ix : &mut [usize],
    mut storage : &mut [u8
]) {
    let mut cmd_histo : [u32; 128];
    let mut ip_end : usize;
    let mut next_emit : usize = 0usize;
    let base_ip : usize = 0usize;
    static kFirstBlockSize : usize = (3i32 << 15i32) as (usize);
    static kMergeBlockSize : usize = (1i32 << 16i32) as (usize);
    let kInputMarginBytes : usize = 16usize;
    let kMinMatchLen : usize = 5usize;
    let mut metablock_start : usize = 0usize;
    let mut block_size
        : usize
        = brotli_min_size_t(input_size,kFirstBlockSize);
    let mut total_block_size : usize = block_size;
    let mut mlen_storage_ix
        : usize
        = (*storage_ix).wrapping_add(3usize);
    let mut lit_depth : [u8; 256];
    let mut lit_bits : [u16; 256];
    let mut literal_ratio : usize;
    let mut ip_index : usize = 0usize;
    let mut input_index : usize = 0usize;
    let mut last_distance : i32;
    let shift : usize = (64u32 as (usize)).wrapping_sub(table_bits);
    BrotliStoreMetaBlockHeader(block_size,0i32,storage_ix,storage);
    BrotliWriteBits(
        13usize,
        0usize,
        storage_ix,
        storage
    );
    literal_ratio = BuildAndStoreLiteralPrefixCode(
                        m,
                        input_ptr[(input_index as (usize))..],
                        block_size,
                        lit_depth.as_mut_ptr(),
                        lit_bits.as_mut_ptr(),
                        storage_ix,
                        storage
                    );
    if !(0i32 == 0) {
        return;
    }
    {
        let mut i : usize;
        i = 0usize;
        while i.wrapping_add(7usize) < *cmd_code_numbits {
            {
                BrotliWriteBits(
                    8usize,
                    cmd_code[((i >> 3i32) as (usize)) ]as (usize),
                    storage_ix,
                    storage
                );
            }
            i = i.wrapping_add(8usize);
        }
    }
    BrotliWriteBits(
        *cmd_code_numbits & 7usize,
        cmd_code[(
             (*cmd_code_numbits >> 3i32) as (usize)
         ) ]as (usize),
        storage_ix,
        storage
    );
    let mut code_block_selection
        : CodeBlockState
        = CodeBlockState::EMIT_COMMANDS;
    while 1i32 != 0 {
        if code_block_selection as (i32) == CodeBlockState::EMIT_COMMANDS as (i32) {
            memcpy(
                cmd_histo.as_mut_ptr() ,
                kCmdHistoSeed.as_mut_ptr() ,
                ::std::mem::size_of::<[u32; 128]>()
            );
            ip_index = input_index;
            last_distance = -1i32;
            ip_end = input_index.wrapping_add(block_size);
            if block_size >= kInputMarginBytes {
                let len_limit
                    : usize
                    = brotli_min_size_t(
                          block_size.wrapping_sub(kMinMatchLen),
                          input_size.wrapping_sub(kInputMarginBytes)
                      );
                let ip_limit : usize = input_index.wrapping_add(len_limit);
                let mut next_hash : u32;
                next_hash = Hash(
                                input_ptr[(
                                    {
                                        ip_index = ip_index.wrapping_add(1 as (usize));
                                        ip_index
                                    } as (usize)
                                )..],
                                shift
                            );
                loop {
                    let mut skip : u32 = 32u32;
                    let mut next_ip : usize = ip_index;
                    let mut candidate : usize;
                    0i32;
                    loop {
                        {
                            'break15: loop {
                                {
                                    let mut hash : u32 = next_hash;
                                    let mut bytes_between_hash_lookups
                                        : u32
                                        = ({
                                               let _old = skip;
                                               skip = skip.wrapping_add(1 as (u32));
                                               _old
                                           }) >> 5i32;
                                    0i32;
                                    ip_index = next_ip;
                                    next_ip = ip_index.wrapping_add(
                                                  bytes_between_hash_lookups as (usize)
                                              );
                                    if next_ip > ip_limit {
                                        code_block_selection = CodeBlockState::EMIT_REMAINDER;
                                        {
                                            {
                                                break 'break15;
                                            }
                                        }
                                    }
                                    next_hash = Hash(input_ptr[(next_ip as (usize))..],shift);
                                    candidate = ip_index.wrapping_sub(last_distance as (usize));
                                    if IsMatch(
                                           input_ptr[(ip_index as (usize))..],
                                           input_ptr[(candidate as (usize)) ..])!= 0 {
                                        if candidate < ip_index {
                                            table[(hash as (usize)) ]= ip_index.wrapping_sub(
                                                                                 base_ip
                                                                             ) as (i32);
                                            {
                                                {
                                                    break 'break15;
                                                }
                                            }
                                        }
                                    }
                                    candidate = base_ip.wrapping_add(
                                                    table[(hash as (usize)) ]as (usize)
                                                );
                                    0i32;
                                    0i32;
                                    table[(hash as (usize)) ]= ip_index.wrapping_sub(
                                                                         base_ip
                                                                     ) as (i32);
                                }
                                if !(IsMatch(
                                         input_ptr[(ip_index as (usize))..],
                                         input_ptr[(candidate as (usize)) ..])== 0) {
                                    break;
                                }
                            }
                        }
                        if !(ip_index.wrapping_sub(
                                 candidate
                             ) > (1usize << 18i32).wrapping_sub(
                                     16usize
                                 ) as (isize) as (usize) && (code_block_selection as (i32) == CodeBlockState::EMIT_COMMANDS as (i32))) {
                            break;
                        }
                    }
                    if code_block_selection as (i32) != CodeBlockState::EMIT_COMMANDS as (i32) {
                        {
                            break;
                        }
                    }
                    {
                        let mut base : usize = ip_index;
                        let mut matched
                            : usize
                            = (5usize).wrapping_add(
                                  FindMatchLengthWithLimit(
                                      input_ptr[(candidate as (usize))..].offset(
                                          5i32 as (isize)
                                      ),
                                      input_ptr[(ip_index as (usize))..].offset(5i32 as (isize)),
                                      ip_end.wrapping_sub(ip_index).wrapping_sub(5usize)
                                  )
                              );
                        let mut distance : i32 = base.wrapping_sub(candidate) as (i32);
                        let mut insert : usize = base.wrapping_sub(next_emit);
                        ip_index = ip_index.wrapping_add(matched);
                        0i32;
                        if insert < 6210usize {
                            EmitInsertLen(
                                insert,
                                cmd_depth ,
                                cmd_bits ,
                                cmd_histo.as_mut_ptr(),
                                storage_ix,
                                storage
                            );
                        } else if ShouldUseUncompressedMode(
                                      input_ptr[(metablock_start as (usize))..],
                                      input_ptr[(next_emit as (usize))..],
                                      insert,
                                      literal_ratio
                                  ) != 0 {
                            EmitUncompressedMetaBlock(
                                input_ptr[(metablock_start as (usize))..],
                                base.wrapping_sub(metablock_start),
                                mlen_storage_ix.wrapping_sub(3usize),
                                storage_ix,
                                storage
                            );
                            input_size = input_size.wrapping_sub(
                                             base.wrapping_sub(input_index)
                                         );
                            input_index = base;
                            next_emit = input_index;
                            code_block_selection = CodeBlockState::NEXT_BLOCK;
                            {
                                {
                                    break;
                                }
                            }
                        } else {
                            EmitLongInsertLen(
                                insert,
                                cmd_depth ,
                                cmd_bits ,
                                cmd_histo.as_mut_ptr(),
                                storage_ix,
                                storage
                            );
                        }
                        EmitLiterals(
                            input_ptr[(next_emit as (usize))..],
                            insert,
                            lit_depth.as_mut_ptr() ,
                            lit_bits.as_mut_ptr() ,
                            storage_ix,
                            storage
                        );
                        if distance == last_distance {
                            BrotliWriteBits(
                                cmd_depth[(64usize) ]as (usize),
                                cmd_bits[(64usize) ]as (usize),
                                storage_ix,
                                storage
                            );
                            {
                                let _rhs = 1;
                                let _lhs = &mut cmd_histo[64usize];
                                *_lhs = (*_lhs).wrapping_add(_rhs as (u32));
                            }
                        } else {
                            EmitDistance(
                                distance as (usize),
                                cmd_depth ,
                                cmd_bits ,
                                cmd_histo.as_mut_ptr(),
                                storage_ix,
                                storage
                            );
                            last_distance = distance;
                        }
                        EmitCopyLenLastDistance(
                            matched,
                            cmd_depth ,
                            cmd_bits ,
                            cmd_histo.as_mut_ptr(),
                            storage_ix,
                            storage
                        );
                        next_emit = ip_index;
                        if ip_index >= ip_limit {
                            code_block_selection = CodeBlockState::EMIT_REMAINDER;
                            {
                                {
                                    break;
                                }
                            }
                        }
                        {
                            let mut input_bytes
                                : usize
                                = BROTLI_UNALIGNED_LOAD64(
                                      input_ptr[(ip_index as (usize))..].offset(
                                          -(3i32 as (isize))
                                      ) 
                                  );
                            let mut prev_hash
                                : u32
                                = HashBytesAtOffset(input_bytes,0i32,shift);
                            let mut cur_hash : u32 = HashBytesAtOffset(input_bytes,3i32,shift);
                            table[(prev_hash as (usize)) ]= ip_index.wrapping_sub(
                                                                      base_ip
                                                                  ).wrapping_sub(
                                                                      3usize
                                                                  ) as (i32);
                            prev_hash = HashBytesAtOffset(input_bytes,1i32,shift);
                            table[(prev_hash as (usize)) ]= ip_index.wrapping_sub(
                                                                      base_ip
                                                                  ).wrapping_sub(
                                                                      2usize
                                                                  ) as (i32);
                            prev_hash = HashBytesAtOffset(input_bytes,2i32,shift);
                            table[(prev_hash as (usize)) ]= ip_index.wrapping_sub(
                                                                      base_ip
                                                                  ).wrapping_sub(
                                                                      1usize
                                                                  ) as (i32);
                            candidate = base_ip.wrapping_add(
                                            table[(cur_hash as (usize)) ]as (usize)
                                        );
                            table[(cur_hash as (usize)) ]= ip_index.wrapping_sub(
                                                                     base_ip
                                                                 ) as (i32);
                        }
                    }
                    while IsMatch(
                              input_ptr[(ip_index as (usize))..],
                              input_ptr[(candidate as (usize)) ..])!= 0 {
                        let mut base : usize = ip_index;
                        let mut matched
                            : usize
                            = (5usize).wrapping_add(
                                  FindMatchLengthWithLimit(
                                      input_ptr[(candidate as (usize))..].offset(
                                          5i32 as (isize)
                                      ),
                                      input_ptr[(ip_index as (usize))..].offset(5i32 as (isize)),
                                      ip_end.wrapping_sub(ip_index).wrapping_sub(5usize)
                                  )
                              );
                        if ip_index.wrapping_sub(
                               candidate
                           ) > (1usize << 18i32).wrapping_sub(
                                   16usize
                               ) as (isize) as (usize) {
                            {
                                break;
                            }
                        }
                        ip_index = ip_index.wrapping_add(matched);
                        last_distance = base.wrapping_sub(candidate) as (i32);
                        0i32;
                        EmitCopyLen(
                            matched,
                            cmd_depth ,
                            cmd_bits ,
                            cmd_histo.as_mut_ptr(),
                            storage_ix,
                            storage
                        );
                        EmitDistance(
                            last_distance as (usize),
                            cmd_depth ,
                            cmd_bits ,
                            cmd_histo.as_mut_ptr(),
                            storage_ix,
                            storage
                        );
                        next_emit = ip_index;
                        if ip_index >= ip_limit {
                            code_block_selection = CodeBlockState::EMIT_REMAINDER;
                            {
                                {
                                    break;
                                }
                            }
                        }
                        {
                            let mut input_bytes
                                : usize
                                = BROTLI_UNALIGNED_LOAD64(
                                      input_ptr[(ip_index as (usize))..].offset(
                                          -(3i32 as (isize))
                                      ) 
                                  );
                            let mut prev_hash
                                : u32
                                = HashBytesAtOffset(input_bytes,0i32,shift);
                            let mut cur_hash : u32 = HashBytesAtOffset(input_bytes,3i32,shift);
                            table[(prev_hash as (usize)) ]= ip_index.wrapping_sub(
                                                                      base_ip
                                                                  ).wrapping_sub(
                                                                      3usize
                                                                  ) as (i32);
                            prev_hash = HashBytesAtOffset(input_bytes,1i32,shift);
                            table[(prev_hash as (usize)) ]= ip_index.wrapping_sub(
                                                                      base_ip
                                                                  ).wrapping_sub(
                                                                      2usize
                                                                  ) as (i32);
                            prev_hash = HashBytesAtOffset(input_bytes,2i32,shift);
                            table[(prev_hash as (usize)) ]= ip_index.wrapping_sub(
                                                                      base_ip
                                                                  ).wrapping_sub(
                                                                      1usize
                                                                  ) as (i32);
                            candidate = base_ip.wrapping_add(
                                            table[(cur_hash as (usize)) ]as (usize)
                                        );
                            table[(cur_hash as (usize)) ]= ip_index.wrapping_sub(
                                                                     base_ip
                                                                 ) as (i32);
                        }
                    }
                    if code_block_selection as (i32) == CodeBlockState::EMIT_REMAINDER as (i32) {
                        break;
                    }
                    if code_block_selection as (i32) == CodeBlockState::EMIT_COMMANDS as (i32) {
                        next_hash = Hash(
                                        input_ptr[(
                                            {
                                                ip_index = ip_index.wrapping_add(1 as (usize));
                                                ip_index
                                            } as (usize)
                                        )..],
                                        shift
                                    );
                    }
                }
            }
            code_block_selection = CodeBlockState::EMIT_REMAINDER;
            {
                {
                    continue;
                }
            }
        } else if code_block_selection as (i32) == CodeBlockState::EMIT_REMAINDER as (i32) {
            0i32;
            input_index = input_index.wrapping_add(block_size);
            input_size = input_size.wrapping_sub(block_size);
            block_size = brotli_min_size_t(input_size,kMergeBlockSize);
            if input_size > 0usize && (total_block_size.wrapping_add(
                                                    block_size
                                                ) <= (1i32 << 20i32) as (usize)) && (ShouldMergeBlock(
                                                                                         input_ptr[(
                                                                                             input_index as (usize)
                                                                                         )..],
                                                                                         block_size,
                                                                                         lit_depth.as_mut_ptr(
                                                                                         ) 
                                                                                     ) != 0) {
                0i32;
                total_block_size = total_block_size.wrapping_add(block_size);
                UpdateBits(
                    20usize,
                    total_block_size.wrapping_sub(1usize) as (u32),
                    mlen_storage_ix,
                    storage
                );
                code_block_selection = CodeBlockState::EMIT_COMMANDS;
                {
                    {
                        continue;
                    }
                }
            }
            if next_emit < ip_end {
                let insert : usize = ip_end.wrapping_sub(next_emit);
                if insert < 6210usize {
                    EmitInsertLen(
                        insert,
                        cmd_depth ,
                        cmd_bits ,
                        cmd_histo.as_mut_ptr(),
                        storage_ix,
                        storage
                    );
                    EmitLiterals(
                        input_ptr[(next_emit as (usize))..],
                        insert,
                        lit_depth.as_mut_ptr() ,
                        lit_bits.as_mut_ptr() ,
                        storage_ix,
                        storage
                    );
                } else if ShouldUseUncompressedMode(
                              input_ptr[(metablock_start as (usize))..],
                              input_ptr[(next_emit as (usize))..],
                              insert,
                              literal_ratio
                          ) != 0 {
                    EmitUncompressedMetaBlock(
                        input_ptr[(metablock_start as (usize))..],
                        ip_end.wrapping_sub(metablock_start),
                        mlen_storage_ix.wrapping_sub(3usize),
                        storage_ix,
                        storage
                    );
                } else {
                    EmitLongInsertLen(
                        insert,
                        cmd_depth ,
                        cmd_bits ,
                        cmd_histo.as_mut_ptr(),
                        storage_ix,
                        storage
                    );
                    EmitLiterals(
                        input_ptr[(next_emit as (usize))..],
                        insert,
                        lit_depth.as_mut_ptr() ,
                        lit_bits.as_mut_ptr() ,
                        storage_ix,
                        storage
                    );
                }
            }
            next_emit = ip_end;
            code_block_selection = CodeBlockState::NEXT_BLOCK;
        } else if code_block_selection as (i32) == CodeBlockState::NEXT_BLOCK as (i32) {
            if input_size > 0usize {
                metablock_start = input_index;
                block_size = brotli_min_size_t(input_size,kFirstBlockSize);
                total_block_size = block_size;
                mlen_storage_ix = (*storage_ix).wrapping_add(3usize);
                BrotliStoreMetaBlockHeader(block_size,0i32,storage_ix,storage);
                BrotliWriteBits(
                    13usize,
                    0usize,
                    storage_ix,
                    storage
                );
                literal_ratio = BuildAndStoreLiteralPrefixCode(
                                    m,
                                    input_ptr[(input_index as (usize))..],
                                    block_size,
                                    lit_depth.as_mut_ptr(),
                                    lit_bits.as_mut_ptr(),
                                    storage_ix,
                                    storage
                                );
                if !(0i32 == 0) {
                    return;
                }
                BuildAndStoreCommandPrefixCode(
                    cmd_histo.as_mut_ptr() ,
                    cmd_depth,
                    cmd_bits,
                    storage_ix,
                    storage
                );
                code_block_selection = CodeBlockState::EMIT_COMMANDS;
                {
                    {
                        continue;
                    }
                }
            }
            {
                {
                    break;
                }
            }
        } else {
            0i32;
        }
    }
    if is_last == 0 {
        cmd_code[(0usize) ]= 0i32 as (u8);
        *cmd_code_numbits = 0usize;
        BuildAndStoreCommandPrefixCode(
            cmd_histo.as_mut_ptr() ,
            cmd_depth,
            cmd_bits,
            cmd_code_numbits,
            cmd_code
        );
    }
}

fn BrotliCompressFragmentFastImpl9(
    mut m : &mut [MemoryManager],
    mut input : & [u8],
    mut input_size : usize,
    mut is_last : i32,
    mut table : &mut [i32],
    mut cmd_depth : &mut [u8],
    mut cmd_bits : &mut [u16],
    mut cmd_code_numbits : &mut [usize],
    mut cmd_code : &mut [u8],
    mut storage_ix : &mut [usize],
    mut storage : &mut [u8
]) {
    BrotliCompressFragmentFastImpl(
        m,
        input,
        input_size,
        is_last,
        table,
        9usize,
        cmd_depth,
        cmd_bits,
        cmd_code_numbits,
        cmd_code,
        storage_ix,
        storage
    );
}

fn BrotliCompressFragmentFastImpl11(
    mut m : &mut [MemoryManager],
    mut input : & [u8],
    mut input_size : usize,
    mut is_last : i32,
    mut table : &mut [i32],
    mut cmd_depth : &mut [u8],
    mut cmd_bits : &mut [u16],
    mut cmd_code_numbits : &mut [usize],
    mut cmd_code : &mut [u8],
    mut storage_ix : &mut [usize],
    mut storage : &mut [u8
]) {
    BrotliCompressFragmentFastImpl(
        m,
        input,
        input_size,
        is_last,
        table,
        11usize,
        cmd_depth,
        cmd_bits,
        cmd_code_numbits,
        cmd_code,
        storage_ix,
        storage
    );
}

fn BrotliCompressFragmentFastImpl13(
    mut m : &mut [MemoryManager],
    mut input : & [u8],
    mut input_size : usize,
    mut is_last : i32,
    mut table : &mut [i32],
    mut cmd_depth : &mut [u8],
    mut cmd_bits : &mut [u16],
    mut cmd_code_numbits : &mut [usize],
    mut cmd_code : &mut [u8],
    mut storage_ix : &mut [usize],
    mut storage : &mut [u8
]) {
    BrotliCompressFragmentFastImpl(
        m,
        input,
        input_size,
        is_last,
        table,
        13usize,
        cmd_depth,
        cmd_bits,
        cmd_code_numbits,
        cmd_code,
        storage_ix,
        storage
    );
}

fn BrotliCompressFragmentFastImpl15(
    mut m : &mut [MemoryManager],
    mut input : & [u8],
    mut input_size : usize,
    mut is_last : i32,
    mut table : &mut [i32],
    mut cmd_depth : &mut [u8],
    mut cmd_bits : &mut [u16],
    mut cmd_code_numbits : &mut [usize],
    mut cmd_code : &mut [u8],
    mut storage_ix : &mut [usize],
    mut storage : &mut [u8
]) {
    BrotliCompressFragmentFastImpl(
        m,
        input,
        input_size,
        is_last,
        table,
        15usize,
        cmd_depth,
        cmd_bits,
        cmd_code_numbits,
        cmd_code,
        storage_ix,
        storage
    );
}


pub fn BrotliCompressFragmentFast(
    mut m : &mut [MemoryManager],
    mut input : & [u8],
    mut input_size : usize,
    mut is_last : i32,
    mut table : &mut [i32],
    mut table_size : usize,
    mut cmd_depth : &mut [u8],
    mut cmd_bits : &mut [u16],
    mut cmd_code_numbits : &mut [usize],
    mut cmd_code : &mut [u8],
    mut storage_ix : &mut [usize],
    mut storage : &mut [u8
]) {
    let initial_storage_ix : usize = *storage_ix;
    let table_bits : usize = Log2FloorNonZero(table_size) as (usize);
    if input_size == 0usize {
        0i32;
        BrotliWriteBits(
            1usize,
            1usize,
            storage_ix,
            storage
        );
        BrotliWriteBits(
            1usize,
            1usize,
            storage_ix,
            storage
        );
        *storage_ix = (*storage_ix).wrapping_add(
                          7u32 as (usize)
                      ) & !7u32 as (usize);
        return;
    }
    if table_bits == 9usize {
        BrotliCompressFragmentFastImpl9(
            m,
            input,
            input_size,
            is_last,
            table,
            cmd_depth,
            cmd_bits,
            cmd_code_numbits,
            cmd_code,
            storage_ix,
            storage
        );
    }
    if table_bits == 11usize {
        BrotliCompressFragmentFastImpl11(
            m,
            input,
            input_size,
            is_last,
            table,
            cmd_depth,
            cmd_bits,
            cmd_code_numbits,
            cmd_code,
            storage_ix,
            storage
        );
    }
    if table_bits == 13usize {
        BrotliCompressFragmentFastImpl13(
            m,
            input,
            input_size,
            is_last,
            table,
            cmd_depth,
            cmd_bits,
            cmd_code_numbits,
            cmd_code,
            storage_ix,
            storage
        );
    }
    if table_bits == 15usize {
        BrotliCompressFragmentFastImpl15(
            m,
            input,
            input_size,
            is_last,
            table,
            cmd_depth,
            cmd_bits,
            cmd_code_numbits,
            cmd_code,
            storage_ix,
            storage
        );
    }
    if (*storage_ix).wrapping_sub(
           initial_storage_ix
       ) > (31usize).wrapping_add(input_size << 3i32) {
        EmitUncompressedMetaBlock(
            input,
            input_size,
            initial_storage_ix,
            storage_ix,
            storage
        );
    }
    if is_last != 0 {
        BrotliWriteBits(
            1usize,
            1usize,
            storage_ix,
            storage
        );
        BrotliWriteBits(
            1usize,
            1usize,
            storage_ix,
            storage
        );
        *storage_ix = (*storage_ix).wrapping_add(
                          7u32 as (usize)
                      ) & !7u32 as (usize);
    }
}
