extern {
    fn BrotliAllocate(
        m : &mut [MemoryManager], n : usize
    ) -> *mut ::std::os::raw::c_void;
    fn BrotliFree(
        m : &mut [MemoryManager], p : &mut [::std::os::raw::c_void
    ]);
    fn BrotliPopulationCostCommand(
        arg1 : & [HistogramCommand
    ]) -> f64;
    fn BrotliPopulationCostDistance(
        arg1 : & [HistogramDistance
    ]) -> f64;
    fn BrotliPopulationCostLiteral(
        arg1 : & [HistogramLiteral
    ]) -> f64;
    fn memcpy(
        __dst : &mut [::std::os::raw::c_void],
        __src : & [::std::os::raw::c_void],
        __n : usize
    ) -> *mut ::std::os::raw::c_void;
    fn memmove(
        __dst : &mut [::std::os::raw::c_void],
        __src : & [::std::os::raw::c_void],
        __len : usize
    ) -> *mut ::std::os::raw::c_void;
    fn memset(
        __b : &mut [::std::os::raw::c_void], __c : i32, __len : usize
    ) -> *mut ::std::os::raw::c_void;
}

static mut kLog2Table
    : [f64; 256]
    = [   0.0000000000000000f64,
          0.0000000000000000f64,
          1.0000000000000000f64,
          1.5849625007211563f64,
          2.0000000000000000f64,
          2.3219280948873622f64,
          2.5849625007211561f64,
          2.8073549220576042f64,
          3.0000000000000000f64,
          3.1699250014423126f64,
          3.3219280948873626f64,
          3.4594316186372978f64,
          3.5849625007211565f64,
          3.7004397181410922f64,
          3.8073549220576037f64,
          3.9068905956085187f64,
          4.0000000000000000f64,
          4.0874628412503400f64,
          4.1699250014423122f64,
          4.2479275134435852f64,
          4.3219280948873626f64,
          4.3923174227787607f64,
          4.4594316186372973f64,
          4.5235619560570131f64,
          4.5849625007211570f64,
          4.6438561897747244f64,
          4.7004397181410926f64,
          4.7548875021634691f64,
          4.8073549220576037f64,
          4.8579809951275728f64,
          4.9068905956085187f64,
          4.9541963103868758f64,
          5.0000000000000000f64,
          5.0443941193584534f64,
          5.0874628412503400f64,
          5.1292830169449664f64,
          5.1699250014423122f64,
          5.2094533656289501f64,
          5.2479275134435852f64,
          5.2854022188622487f64,
          5.3219280948873626f64,
          5.3575520046180838f64,
          5.3923174227787607f64,
          5.4262647547020979f64,
          5.4594316186372973f64,
          5.4918530963296748f64,
          5.5235619560570131f64,
          5.5545888516776376f64,
          5.5849625007211570f64,
          5.6147098441152083f64,
          5.6438561897747244f64,
          5.6724253419714961f64,
          5.7004397181410926f64,
          5.7279204545631996f64,
          5.7548875021634691f64,
          5.7813597135246599f64,
          5.8073549220576046f64,
          5.8328900141647422f64,
          5.8579809951275719f64,
          5.8826430493618416f64,
          5.9068905956085187f64,
          5.9307373375628867f64,
          5.9541963103868758f64,
          5.9772799234999168f64,
          6.0000000000000000f64,
          6.0223678130284544f64,
          6.0443941193584534f64,
          6.0660891904577721f64,
          6.0874628412503400f64,
          6.1085244567781700f64,
          6.1292830169449672f64,
          6.1497471195046822f64,
          6.1699250014423122f64,
          6.1898245588800176f64,
          6.2094533656289510f64,
          6.2288186904958804f64,
          6.2479275134435861f64,
          6.2667865406949019f64,
          6.2854022188622487f64,
          6.3037807481771031f64,
          6.3219280948873617f64,
          6.3398500028846252f64,
          6.3575520046180847f64,
          6.3750394313469254f64,
          6.3923174227787598f64,
          6.4093909361377026f64,
          6.4262647547020979f64,
          6.4429434958487288f64,
          6.4594316186372982f64,
          6.4757334309663976f64,
          6.4918530963296748f64,
          6.5077946401986964f64,
          6.5235619560570131f64,
          6.5391588111080319f64,
          6.5545888516776376f64,
          6.5698556083309478f64,
          6.5849625007211561f64,
          6.5999128421871278f64,
          6.6147098441152092f64,
          6.6293566200796095f64,
          6.6438561897747253f64,
          6.6582114827517955f64,
          6.6724253419714952f64,
          6.6865005271832185f64,
          6.7004397181410917f64,
          6.7142455176661224f64,
          6.7279204545631988f64,
          6.7414669864011465f64,
          6.7548875021634691f64,
          6.7681843247769260f64,
          6.7813597135246599f64,
          6.7944158663501062f64,
          6.8073549220576037f64,
          6.8201789624151887f64,
          6.8328900141647422f64,
          6.8454900509443757f64,
          6.8579809951275719f64,
          6.8703647195834048f64,
          6.8826430493618416f64,
          6.8948177633079437f64,
          6.9068905956085187f64,
          6.9188632372745955f64,
          6.9307373375628867f64,
          6.9425145053392399f64,
          6.9541963103868758f64,
          6.9657842846620879f64,
          6.9772799234999168f64,
          6.9886846867721664f64,
          7.0000000000000000f64,
          7.0112272554232540f64,
          7.0223678130284544f64,
          7.0334230015374501f64,
          7.0443941193584534f64,
          7.0552824355011898f64,
          7.0660891904577721f64,
          7.0768155970508317f64,
          7.0874628412503400f64,
          7.0980320829605272f64,
          7.1085244567781700f64,
          7.1189410727235076f64,
          7.1292830169449664f64,
          7.1395513523987937f64,
          7.1497471195046822f64,
          7.1598713367783891f64,
          7.1699250014423130f64,
          7.1799090900149345f64,
          7.1898245588800176f64,
          7.1996723448363644f64,
          7.2094533656289492f64,
          7.2191685204621621f64,
          7.2288186904958804f64,
          7.2384047393250794f64,
          7.2479275134435861f64,
          7.2573878426926521f64,
          7.2667865406949019f64,
          7.2761244052742384f64,
          7.2854022188622487f64,
          7.2946207488916270f64,
          7.3037807481771031f64,
          7.3128829552843557f64,
          7.3219280948873617f64,
          7.3309168781146177f64,
          7.3398500028846243f64,
          7.3487281542310781f64,
          7.3575520046180847f64,
          7.3663222142458151f64,
          7.3750394313469254f64,
          7.3837042924740528f64,
          7.3923174227787607f64,
          7.4008794362821844f64,
          7.4093909361377026f64,
          7.4178525148858991f64,
          7.4262647547020979f64,
          7.4346282276367255f64,
          7.4429434958487288f64,
          7.4512111118323299f64,
          7.4594316186372973f64,
          7.4676055500829976f64,
          7.4757334309663976f64,
          7.4838157772642564f64,
          7.4918530963296748f64,
          7.4998458870832057f64,
          7.5077946401986964f64,
          7.5156998382840436f64,
          7.5235619560570131f64,
          7.5313814605163119f64,
          7.5391588111080319f64,
          7.5468944598876373f64,
          7.5545888516776376f64,
          7.5622424242210728f64,
          7.5698556083309478f64,
          7.5774288280357487f64,
          7.5849625007211561f64,
          7.5924570372680806f64,
          7.5999128421871278f64,
          7.6073303137496113f64,
          7.6147098441152075f64,
          7.6220518194563764f64,
          7.6293566200796095f64,
          7.6366246205436488f64,
          7.6438561897747244f64,
          7.6510516911789290f64,
          7.6582114827517955f64,
          7.6653359171851765f64,
          7.6724253419714952f64,
          7.6794800995054464f64,
          7.6865005271832185f64,
          7.6934869574993252f64,
          7.7004397181410926f64,
          7.7073591320808825f64,
          7.7142455176661224f64,
          7.7210991887071856f64,
          7.7279204545631996f64,
          7.7347096202258392f64,
          7.7414669864011465f64,
          7.7481928495894596f64,
          7.7548875021634691f64,
          7.7615512324444795f64,
          7.7681843247769260f64,
          7.7747870596011737f64,
          7.7813597135246608f64,
          7.7879025593914317f64,
          7.7944158663501062f64,
          7.8008998999203047f64,
          7.8073549220576037f64,
          7.8137811912170374f64,
          7.8201789624151887f64,
          7.8265484872909159f64,
          7.8328900141647422f64,
          7.8392037880969445f64,
          7.8454900509443757f64,
          7.8517490414160571f64,
          7.8579809951275719f64,
          7.8641861446542798f64,
          7.8703647195834048f64,
          7.8765169465650002f64,
          7.8826430493618425f64,
          7.8887432488982601f64,
          7.8948177633079446f64,
          7.9008668079807496f64,
          7.9068905956085187f64,
          7.9128893362299619f64,
          7.9188632372745955f64,
          7.9248125036057813f64,
          7.9307373375628867f64,
          7.9366379390025719f64,
          7.9425145053392399f64,
          7.9483672315846778f64,
          7.9541963103868758f64,
          7.9600019320680806f64,
          7.9657842846620870f64,
          7.9715435539507720f64,
          7.9772799234999168f64,
          7.9829935746943104f64,
          7.9886846867721664f64,
          7.9943534368588578f64
      ];


pub fn log2(mut v : f64) -> f64 {
    if v < 0i32 as (f64) {
        0i32 as (f64)
    } else if v < 256i32 as (f64) {
        kLog2Table[v as (usize)]
    } else {
        let mut count : f64 = 0i32 as (f64);
        while 1i32 != 0 {
            v = v / 2i32 as (f64);
            count = count + 1.0f64;
            if v < 256i32 as (f64) {
                return kLog2Table[v as (usize)] + count;
            }
        }
    }
}

static mut kLog2Table
    : [f32; 256]
    = [   0.0000000000000000f32,
          0.0000000000000000f32,
          1.0000000000000000f32,
          1.5849625007211563f32,
          2.0000000000000000f32,
          2.3219280948873622f32,
          2.5849625007211561f32,
          2.8073549220576042f32,
          3.0000000000000000f32,
          3.1699250014423126f32,
          3.3219280948873626f32,
          3.4594316186372978f32,
          3.5849625007211565f32,
          3.7004397181410922f32,
          3.8073549220576037f32,
          3.9068905956085187f32,
          4.0000000000000000f32,
          4.0874628412503400f32,
          4.1699250014423122f32,
          4.2479275134435852f32,
          4.3219280948873626f32,
          4.3923174227787607f32,
          4.4594316186372973f32,
          4.5235619560570131f32,
          4.5849625007211570f32,
          4.6438561897747244f32,
          4.7004397181410926f32,
          4.7548875021634691f32,
          4.8073549220576037f32,
          4.8579809951275728f32,
          4.9068905956085187f32,
          4.9541963103868758f32,
          5.0000000000000000f32,
          5.0443941193584534f32,
          5.0874628412503400f32,
          5.1292830169449664f32,
          5.1699250014423122f32,
          5.2094533656289501f32,
          5.2479275134435852f32,
          5.2854022188622487f32,
          5.3219280948873626f32,
          5.3575520046180838f32,
          5.3923174227787607f32,
          5.4262647547020979f32,
          5.4594316186372973f32,
          5.4918530963296748f32,
          5.5235619560570131f32,
          5.5545888516776376f32,
          5.5849625007211570f32,
          5.6147098441152083f32,
          5.6438561897747244f32,
          5.6724253419714961f32,
          5.7004397181410926f32,
          5.7279204545631996f32,
          5.7548875021634691f32,
          5.7813597135246599f32,
          5.8073549220576046f32,
          5.8328900141647422f32,
          5.8579809951275719f32,
          5.8826430493618416f32,
          5.9068905956085187f32,
          5.9307373375628867f32,
          5.9541963103868758f32,
          5.9772799234999168f32,
          6.0000000000000000f32,
          6.0223678130284544f32,
          6.0443941193584534f32,
          6.0660891904577721f32,
          6.0874628412503400f32,
          6.1085244567781700f32,
          6.1292830169449672f32,
          6.1497471195046822f32,
          6.1699250014423122f32,
          6.1898245588800176f32,
          6.2094533656289510f32,
          6.2288186904958804f32,
          6.2479275134435861f32,
          6.2667865406949019f32,
          6.2854022188622487f32,
          6.3037807481771031f32,
          6.3219280948873617f32,
          6.3398500028846252f32,
          6.3575520046180847f32,
          6.3750394313469254f32,
          6.3923174227787598f32,
          6.4093909361377026f32,
          6.4262647547020979f32,
          6.4429434958487288f32,
          6.4594316186372982f32,
          6.4757334309663976f32,
          6.4918530963296748f32,
          6.5077946401986964f32,
          6.5235619560570131f32,
          6.5391588111080319f32,
          6.5545888516776376f32,
          6.5698556083309478f32,
          6.5849625007211561f32,
          6.5999128421871278f32,
          6.6147098441152092f32,
          6.6293566200796095f32,
          6.6438561897747253f32,
          6.6582114827517955f32,
          6.6724253419714952f32,
          6.6865005271832185f32,
          6.7004397181410917f32,
          6.7142455176661224f32,
          6.7279204545631988f32,
          6.7414669864011465f32,
          6.7548875021634691f32,
          6.7681843247769260f32,
          6.7813597135246599f32,
          6.7944158663501062f32,
          6.8073549220576037f32,
          6.8201789624151887f32,
          6.8328900141647422f32,
          6.8454900509443757f32,
          6.8579809951275719f32,
          6.8703647195834048f32,
          6.8826430493618416f32,
          6.8948177633079437f32,
          6.9068905956085187f32,
          6.9188632372745955f32,
          6.9307373375628867f32,
          6.9425145053392399f32,
          6.9541963103868758f32,
          6.9657842846620879f32,
          6.9772799234999168f32,
          6.9886846867721664f32,
          7.0000000000000000f32,
          7.0112272554232540f32,
          7.0223678130284544f32,
          7.0334230015374501f32,
          7.0443941193584534f32,
          7.0552824355011898f32,
          7.0660891904577721f32,
          7.0768155970508317f32,
          7.0874628412503400f32,
          7.0980320829605272f32,
          7.1085244567781700f32,
          7.1189410727235076f32,
          7.1292830169449664f32,
          7.1395513523987937f32,
          7.1497471195046822f32,
          7.1598713367783891f32,
          7.1699250014423130f32,
          7.1799090900149345f32,
          7.1898245588800176f32,
          7.1996723448363644f32,
          7.2094533656289492f32,
          7.2191685204621621f32,
          7.2288186904958804f32,
          7.2384047393250794f32,
          7.2479275134435861f32,
          7.2573878426926521f32,
          7.2667865406949019f32,
          7.2761244052742384f32,
          7.2854022188622487f32,
          7.2946207488916270f32,
          7.3037807481771031f32,
          7.3128829552843557f32,
          7.3219280948873617f32,
          7.3309168781146177f32,
          7.3398500028846243f32,
          7.3487281542310781f32,
          7.3575520046180847f32,
          7.3663222142458151f32,
          7.3750394313469254f32,
          7.3837042924740528f32,
          7.3923174227787607f32,
          7.4008794362821844f32,
          7.4093909361377026f32,
          7.4178525148858991f32,
          7.4262647547020979f32,
          7.4346282276367255f32,
          7.4429434958487288f32,
          7.4512111118323299f32,
          7.4594316186372973f32,
          7.4676055500829976f32,
          7.4757334309663976f32,
          7.4838157772642564f32,
          7.4918530963296748f32,
          7.4998458870832057f32,
          7.5077946401986964f32,
          7.5156998382840436f32,
          7.5235619560570131f32,
          7.5313814605163119f32,
          7.5391588111080319f32,
          7.5468944598876373f32,
          7.5545888516776376f32,
          7.5622424242210728f32,
          7.5698556083309478f32,
          7.5774288280357487f32,
          7.5849625007211561f32,
          7.5924570372680806f32,
          7.5999128421871278f32,
          7.6073303137496113f32,
          7.6147098441152075f32,
          7.6220518194563764f32,
          7.6293566200796095f32,
          7.6366246205436488f32,
          7.6438561897747244f32,
          7.6510516911789290f32,
          7.6582114827517955f32,
          7.6653359171851765f32,
          7.6724253419714952f32,
          7.6794800995054464f32,
          7.6865005271832185f32,
          7.6934869574993252f32,
          7.7004397181410926f32,
          7.7073591320808825f32,
          7.7142455176661224f32,
          7.7210991887071856f32,
          7.7279204545631996f32,
          7.7347096202258392f32,
          7.7414669864011465f32,
          7.7481928495894596f32,
          7.7548875021634691f32,
          7.7615512324444795f32,
          7.7681843247769260f32,
          7.7747870596011737f32,
          7.7813597135246608f32,
          7.7879025593914317f32,
          7.7944158663501062f32,
          7.8008998999203047f32,
          7.8073549220576037f32,
          7.8137811912170374f32,
          7.8201789624151887f32,
          7.8265484872909159f32,
          7.8328900141647422f32,
          7.8392037880969445f32,
          7.8454900509443757f32,
          7.8517490414160571f32,
          7.8579809951275719f32,
          7.8641861446542798f32,
          7.8703647195834048f32,
          7.8765169465650002f32,
          7.8826430493618425f32,
          7.8887432488982601f32,
          7.8948177633079446f32,
          7.9008668079807496f32,
          7.9068905956085187f32,
          7.9128893362299619f32,
          7.9188632372745955f32,
          7.9248125036057813f32,
          7.9307373375628867f32,
          7.9366379390025719f32,
          7.9425145053392399f32,
          7.9483672315846778f32,
          7.9541963103868758f32,
          7.9600019320680806f32,
          7.9657842846620870f32,
          7.9715435539507720f32,
          7.9772799234999168f32,
          7.9829935746943104f32,
          7.9886846867721664f32,
          7.9943534368588578f32
      ];

static mut kInsBase
    : [u32; 24]
    = [   0u32,
          1u32,
          2u32,
          3u32,
          4u32,
          5u32,
          6u32,
          8u32,
          10u32,
          14u32,
          18u32,
          26u32,
          34u32,
          50u32,
          66u32,
          98u32,
          130u32,
          194u32,
          322u32,
          578u32,
          1090u32,
          2114u32,
          6210u32,
          22594u32
      ];

static mut kInsExtra
    : [u32; 24]
    = [   0u32,
          0u32,
          0u32,
          0u32,
          0u32,
          0u32,
          1u32,
          1u32,
          2u32,
          2u32,
          3u32,
          3u32,
          4u32,
          4u32,
          5u32,
          5u32,
          6u32,
          7u32,
          8u32,
          9u32,
          10u32,
          12u32,
          14u32,
          24u32
      ];

static mut kCopyBase
    : [u32; 24]
    = [   2u32,
          3u32,
          4u32,
          5u32,
          6u32,
          7u32,
          8u32,
          9u32,
          10u32,
          12u32,
          14u32,
          18u32,
          22u32,
          30u32,
          38u32,
          54u32,
          70u32,
          102u32,
          134u32,
          198u32,
          326u32,
          582u32,
          1094u32,
          2118u32
      ];

static mut kCopyExtra
    : [u32; 24]
    = [   0u32,
          0u32,
          0u32,
          0u32,
          0u32,
          0u32,
          0u32,
          0u32,
          1u32,
          1u32,
          2u32,
          2u32,
          3u32,
          3u32,
          4u32,
          4u32,
          5u32,
          5u32,
          6u32,
          7u32,
          8u32,
          9u32,
          10u32,
          24u32
      ];

static kBrotliMinWindowBits : i32 = 10i32;

static kBrotliMaxWindowBits : i32 = 24i32;

static mut kUTF8ContextLookup
    : [u8; 512]
    = [   0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          4i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          8i32 as (u8),
          12i32 as (u8),
          16i32 as (u8),
          12i32 as (u8),
          12i32 as (u8),
          20i32 as (u8),
          12i32 as (u8),
          16i32 as (u8),
          24i32 as (u8),
          28i32 as (u8),
          12i32 as (u8),
          12i32 as (u8),
          32i32 as (u8),
          12i32 as (u8),
          36i32 as (u8),
          12i32 as (u8),
          44i32 as (u8),
          44i32 as (u8),
          44i32 as (u8),
          44i32 as (u8),
          44i32 as (u8),
          44i32 as (u8),
          44i32 as (u8),
          44i32 as (u8),
          44i32 as (u8),
          44i32 as (u8),
          32i32 as (u8),
          32i32 as (u8),
          24i32 as (u8),
          40i32 as (u8),
          28i32 as (u8),
          12i32 as (u8),
          12i32 as (u8),
          48i32 as (u8),
          52i32 as (u8),
          52i32 as (u8),
          52i32 as (u8),
          48i32 as (u8),
          52i32 as (u8),
          52i32 as (u8),
          52i32 as (u8),
          48i32 as (u8),
          52i32 as (u8),
          52i32 as (u8),
          52i32 as (u8),
          52i32 as (u8),
          52i32 as (u8),
          48i32 as (u8),
          52i32 as (u8),
          52i32 as (u8),
          52i32 as (u8),
          52i32 as (u8),
          52i32 as (u8),
          48i32 as (u8),
          52i32 as (u8),
          52i32 as (u8),
          52i32 as (u8),
          52i32 as (u8),
          52i32 as (u8),
          24i32 as (u8),
          12i32 as (u8),
          28i32 as (u8),
          12i32 as (u8),
          12i32 as (u8),
          12i32 as (u8),
          56i32 as (u8),
          60i32 as (u8),
          60i32 as (u8),
          60i32 as (u8),
          56i32 as (u8),
          60i32 as (u8),
          60i32 as (u8),
          60i32 as (u8),
          56i32 as (u8),
          60i32 as (u8),
          60i32 as (u8),
          60i32 as (u8),
          60i32 as (u8),
          60i32 as (u8),
          56i32 as (u8),
          60i32 as (u8),
          60i32 as (u8),
          60i32 as (u8),
          60i32 as (u8),
          60i32 as (u8),
          56i32 as (u8),
          60i32 as (u8),
          60i32 as (u8),
          60i32 as (u8),
          60i32 as (u8),
          60i32 as (u8),
          24i32 as (u8),
          12i32 as (u8),
          28i32 as (u8),
          12i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          1i32 as (u8),
          0i32 as (u8),
          1i32 as (u8),
          0i32 as (u8),
          1i32 as (u8),
          0i32 as (u8),
          1i32 as (u8),
          0i32 as (u8),
          1i32 as (u8),
          0i32 as (u8),
          1i32 as (u8),
          0i32 as (u8),
          1i32 as (u8),
          0i32 as (u8),
          1i32 as (u8),
          0i32 as (u8),
          1i32 as (u8),
          0i32 as (u8),
          1i32 as (u8),
          0i32 as (u8),
          1i32 as (u8),
          0i32 as (u8),
          1i32 as (u8),
          0i32 as (u8),
          1i32 as (u8),
          0i32 as (u8),
          1i32 as (u8),
          0i32 as (u8),
          1i32 as (u8),
          0i32 as (u8),
          1i32 as (u8),
          0i32 as (u8),
          1i32 as (u8),
          0i32 as (u8),
          1i32 as (u8),
          0i32 as (u8),
          1i32 as (u8),
          0i32 as (u8),
          1i32 as (u8),
          0i32 as (u8),
          1i32 as (u8),
          0i32 as (u8),
          1i32 as (u8),
          0i32 as (u8),
          1i32 as (u8),
          0i32 as (u8),
          1i32 as (u8),
          0i32 as (u8),
          1i32 as (u8),
          0i32 as (u8),
          1i32 as (u8),
          0i32 as (u8),
          1i32 as (u8),
          0i32 as (u8),
          1i32 as (u8),
          0i32 as (u8),
          1i32 as (u8),
          0i32 as (u8),
          1i32 as (u8),
          0i32 as (u8),
          1i32 as (u8),
          0i32 as (u8),
          1i32 as (u8),
          2i32 as (u8),
          3i32 as (u8),
          2i32 as (u8),
          3i32 as (u8),
          2i32 as (u8),
          3i32 as (u8),
          2i32 as (u8),
          3i32 as (u8),
          2i32 as (u8),
          3i32 as (u8),
          2i32 as (u8),
          3i32 as (u8),
          2i32 as (u8),
          3i32 as (u8),
          2i32 as (u8),
          3i32 as (u8),
          2i32 as (u8),
          3i32 as (u8),
          2i32 as (u8),
          3i32 as (u8),
          2i32 as (u8),
          3i32 as (u8),
          2i32 as (u8),
          3i32 as (u8),
          2i32 as (u8),
          3i32 as (u8),
          2i32 as (u8),
          3i32 as (u8),
          2i32 as (u8),
          3i32 as (u8),
          2i32 as (u8),
          3i32 as (u8),
          2i32 as (u8),
          3i32 as (u8),
          2i32 as (u8),
          3i32 as (u8),
          2i32 as (u8),
          3i32 as (u8),
          2i32 as (u8),
          3i32 as (u8),
          2i32 as (u8),
          3i32 as (u8),
          2i32 as (u8),
          3i32 as (u8),
          2i32 as (u8),
          3i32 as (u8),
          2i32 as (u8),
          3i32 as (u8),
          2i32 as (u8),
          3i32 as (u8),
          2i32 as (u8),
          3i32 as (u8),
          2i32 as (u8),
          3i32 as (u8),
          2i32 as (u8),
          3i32 as (u8),
          2i32 as (u8),
          3i32 as (u8),
          2i32 as (u8),
          3i32 as (u8),
          2i32 as (u8),
          3i32 as (u8),
          2i32 as (u8),
          3i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          0i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8)
      ];

static mut kSigned3BitContextLookup
    : [u8; 256]
    = [   0i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          1i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          2i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          3i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          4i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          5i32 as (u8),
          6i32 as (u8),
          6i32 as (u8),
          6i32 as (u8),
          6i32 as (u8),
          6i32 as (u8),
          6i32 as (u8),
          6i32 as (u8),
          6i32 as (u8),
          6i32 as (u8),
          6i32 as (u8),
          6i32 as (u8),
          6i32 as (u8),
          6i32 as (u8),
          6i32 as (u8),
          6i32 as (u8),
          7i32 as (u8)
      ];



pub struct HistogramLiteral {
    pub data_ : [u32; 256],
    pub total_count_ : usize,
    pub bit_cost_ : f64,
}



pub struct HistogramPair {
    pub idx1 : u32,
    pub idx2 : u32,
    pub cost_combo : f64,
    pub cost_diff : f64,
}

fn FastLog2(mut v : usize) -> f64 {
    if v < ::std::mem::size_of::<[f32; 256]>().wrapping_div(
               ::std::mem::size_of::<f32>()
           ) {
        return kLog2Table[v] as (f64);
    }
    log2(v as (f64))
}

fn ClusterCostDiff(
    mut size_a : usize, mut size_b : usize
) -> f64 {
    let mut size_c : usize = size_a.wrapping_add(size_b);
    size_a as (f64) * FastLog2(size_a) + size_b as (f64) * FastLog2(
                                                               size_b
                                                           ) - size_c as (f64) * FastLog2(size_c)
}

fn brotli_max_double(
    mut a : f64, mut b : f64
) -> f64 {
    if a > b { a } else { b }
}

fn HistogramAddHistogramLiteral(
    mut xself : &mut HistogramLiteral, mut v : & [HistogramLiteral
]) {
    let mut i : usize;
    (*xself).total_count_ = (*xself).total_count_.wrapping_add(
                               (*v).total_count_
                           );
    i = 0usize;
    while i < 256usize {
        {
            let _rhs = (*v).data_[i];
            let _lhs = &mut (*xself).data_[i];
            *_lhs = (*_lhs).wrapping_add(_rhs);
        }
        i = i.wrapping_add(1 as (usize));
    }
}

fn HistogramPairIsLess(
    mut p1 : & [HistogramPair], mut p2 : & [HistogramPair
]) -> i32 {
    if (*p1).cost_diff != (*p2).cost_diff {
        return
            if !!((*p1).cost_diff > (*p2).cost_diff) { 1i32 } else { 0i32 };
    }
    if !!((*p1).idx2.wrapping_sub(
              (*p1).idx1
          ) > (*p2).idx2.wrapping_sub((*p2).idx1)) {
        1i32
    } else {
        0i32
    }
}


pub fn BrotliCompareAndPushToQueueLiteral(
    mut out : & [HistogramLiteral],
    mut cluster_size : & [u32],
    mut idx1 : u32,
    mut idx2 : u32,
    mut max_num_pairs : usize,
    mut pairs : &mut [HistogramPair],
    mut num_pairs : &mut [usize
]) {
    let mut is_good_pair : i32 = 0i32;
    let mut p : HistogramPair;
    if idx1 == idx2 {
        return;
    }
    if idx2 < idx1 {
        let mut t : u32 = idx2;
        idx2 = idx1;
        idx1 = t;
    }
    p.idx1 = idx1;
    p.idx2 = idx2;
    p.cost_diff = 0.5f64 * ClusterCostDiff(
                               cluster_size[(idx1 as (usize)) ]as (usize),
                               cluster_size[(idx2 as (usize)) ]as (usize)
                           );
    p.cost_diff = p.cost_diff - (out[(
                                      idx1 as (usize)
                                  )]).bit_cost_;
    p.cost_diff = p.cost_diff - (out[(
                                      idx2 as (usize)
                                  )]).bit_cost_;
    if (out[(idx1 as (usize))]).total_count_ == 0usize {
        p.cost_combo = (out[(idx2 as (usize))]).bit_cost_;
        is_good_pair = 1i32;
    } else if (out[(
                    idx2 as (usize)
                )]).total_count_ == 0usize {
        p.cost_combo = (out[(idx1 as (usize))]).bit_cost_;
        is_good_pair = 1i32;
    } else {
        let mut threshold
            : f64
            = if *num_pairs == 0usize {
                  1e99f64
              } else {
                  brotli_max_double(
                      0.0f64,
                      (pairs[(0usize)]).cost_diff
                  )
              };
        let mut combo : HistogramLiteral = out[(idx1 as (usize))];
        let mut cost_combo : f64;
        HistogramAddHistogramLiteral(
            &mut combo ,
            &out[(idx2 as (usize)) ]
        );
        cost_combo = BrotliPopulationCostLiteral(
                         &mut combo  
                     );
        if cost_combo < threshold - p.cost_diff {
            p.cost_combo = cost_combo;
            is_good_pair = 1i32;
        }
    }
    if is_good_pair != 0 {
        p.cost_diff = p.cost_diff + p.cost_combo;
        if *num_pairs > 0usize && (HistogramPairIsLess(
                                                &mut pairs[(
                                                          0usize
                                                      ) ] ,
                                                &mut p  
                                            ) != 0) {
            if *num_pairs < max_num_pairs {
                pairs[(*num_pairs as (usize)) ]= pairs[(
                                                            0usize
                                                        )];
                *num_pairs = (*num_pairs).wrapping_add(1 as (usize));
            }
            pairs[(0usize) ]= p;
        } else if *num_pairs < max_num_pairs {
            pairs[(*num_pairs as (usize)) ]= p;
            *num_pairs = (*num_pairs).wrapping_add(1 as (usize));
        }
    }
}


pub fn BrotliHistogramCombineLiteral(
    mut out : &mut [HistogramLiteral],
    mut cluster_size : &mut [u32],
    mut symbols : &mut [u32],
    mut clusters : &mut [u32],
    mut pairs : &mut [HistogramPair],
    mut num_clusters : usize,
    mut symbols_size : usize,
    mut max_clusters : usize,
    mut max_num_pairs : usize
) -> usize {
    let mut cost_diff_threshold : f64 = 0.0f64;
    let mut min_cluster_size : usize = 1usize;
    let mut num_pairs : usize = 0usize;
    {
        let mut idx1 : usize;
        idx1 = 0usize;
        while idx1 < num_clusters {
            {
                let mut idx2 : usize;
                idx2 = idx1.wrapping_add(1usize);
                while idx2 < num_clusters {
                    {
                        BrotliCompareAndPushToQueueLiteral(
                            out ,
                            cluster_size ,
                            clusters[(idx1 as (usize))],
                            clusters[(idx2 as (usize))],
                            max_num_pairs,
                            &mut pairs[(0usize) ],
                            &mut num_pairs 
                        );
                    }
                    idx2 = idx2.wrapping_add(1 as (usize));
                }
            }
            idx1 = idx1.wrapping_add(1 as (usize));
        }
    }
    while num_clusters > min_cluster_size {
        let mut best_idx1 : u32;
        let mut best_idx2 : u32;
        let mut i : usize;
        if (pairs[(
                 0usize
             )]).cost_diff >= cost_diff_threshold {
            cost_diff_threshold = 1e99f64;
            min_cluster_size = max_clusters;
            {
                {
                    continue;
                }
            }
        }
        best_idx1 = (pairs[(0usize)]).idx1;
        best_idx2 = (pairs[(0usize)]).idx2;
        HistogramAddHistogramLiteral(
            &mut out[(best_idx1 as (usize)) ],
            &mut out[(
                      best_idx2 as (usize)
                  ) ] 
        );
        (out[(best_idx1 as (usize))]).bit_cost_ = (pairs[(
                                                              0usize
                                                          )]).cost_combo;
        {
            let _rhs = cluster_size[(best_idx2 as (usize))];
            let _lhs = &mut cluster_size[(best_idx1 as (usize))];
            *_lhs = (*_lhs).wrapping_add(_rhs);
        }
        i = 0usize;
        while i < symbols_size {
            {
                if symbols[(i as (usize)) ]== best_idx2 {
                    symbols[(i as (usize)) ]= best_idx1;
                }
            }
            i = i.wrapping_add(1 as (usize));
        }
        i = 0usize;
        'break9: while i < num_clusters {
            {
                if clusters[(i as (usize)) ]== best_idx2 {
                    memmove(
                        &mut clusters[(
                                  i as (usize)
                              ) ] ,
                        &mut clusters[(
                                  i.wrapping_add(1usize) as (usize)
                              ) ] ,
                        num_clusters.wrapping_sub(i).wrapping_sub(
                            1usize
                        ).wrapping_mul(
                            ::std::mem::size_of::<u32>()
                        )
                    );
                    {
                        {
                            break 'break9;
                        }
                    }
                }
            }
            i = i.wrapping_add(1 as (usize));
        }
        num_clusters = num_clusters.wrapping_sub(1 as (usize));
        {
            let mut copy_to_idx : usize = 0usize;
            i = 0usize;
            while i < num_pairs {
                'continue12: loop {
                    {
                        let mut p
                            : *mut HistogramPair
                            = &mut pairs[(i as (usize)) ];
                        if (*p).idx1 == best_idx1 || (*p).idx2 == best_idx1 || (*p).idx1 == best_idx2 || (*p).idx2 == best_idx2 {
                            {
                                break 'continue12;
                            }
                        }
                        if HistogramPairIsLess(
                               &mut pairs[(
                                         0usize
                                     ) ] ,
                               p 
                           ) != 0 {
                            let mut front : HistogramPair = pairs[(0usize)];
                            pairs[(0usize) ]= *p;
                            pairs[(copy_to_idx as (usize)) ]= front;
                        } else {
                            pairs[(copy_to_idx as (usize)) ]= *p;
                        }
                        copy_to_idx = copy_to_idx.wrapping_add(1 as (usize));
                    }
                    break;
                }
                i = i.wrapping_add(1 as (usize));
            }
            num_pairs = copy_to_idx;
        }
        i = 0usize;
        while i < num_clusters {
            {
                BrotliCompareAndPushToQueueLiteral(
                    out ,
                    cluster_size ,
                    best_idx1,
                    clusters[(i as (usize))],
                    max_num_pairs,
                    &mut pairs[(0usize) ],
                    &mut num_pairs 
                );
            }
            i = i.wrapping_add(1 as (usize));
        }
    }
    num_clusters
}


pub fn BrotliHistogramBitCostDistanceLiteral(
    mut histogram : & [HistogramLiteral],
    mut candidate : & [HistogramLiteral
]) -> f64 {
    if (*histogram).total_count_ == 0usize {
        0.0f64
    } else {
        let mut tmp : HistogramLiteral = *histogram;
        HistogramAddHistogramLiteral(
            &mut tmp ,
            candidate
        );
        BrotliPopulationCostLiteral(
            &mut tmp  
        ) - (*candidate).bit_cost_
    }
}

fn HistogramClearLiteral(
    mut xself : &mut HistogramLiteral
) {
    memset(
        (*xself).data_.as_mut_ptr() ,
        0i32,
        ::std::mem::size_of::<[u32; 256]>()
    );
    (*xself).total_count_ = 0usize;
    (*xself).bit_cost_ = 3.402e+38f64;
}


pub fn BrotliHistogramRemapLiteral(
    mut inp : & [HistogramLiteral],
    mut in_size : usize,
    mut clusters : & [u32],
    mut num_clusters : usize,
    mut out : &mut [HistogramLiteral],
    mut symbols : &mut [u32
]) {
    let mut i : usize;
    i = 0usize;
    while i < in_size {
        {
            let mut best_out
                : u32
                = if i == 0usize {
                      symbols[(0usize) ]}else {
                      symbols[(i.wrapping_sub(1usize) as (usize))]};
            let mut best_bits
                : f64
                = BrotliHistogramBitCostDistanceLiteral(
                      &inp[(i as (usize)) ],
                      &mut out[(
                                best_out as (usize)
                            ) ] 
                  );
            let mut j : usize;
            j = 0usize;
            while j < num_clusters {
                {
                    let cur_bits
                        : f64
                        = BrotliHistogramBitCostDistanceLiteral(
                              &inp[(i as (usize)) ],
                              &mut *out[(
                                        clusters[(j as (usize)) ]as (usize)
                                    ) ..] 
                          );
                    if cur_bits < best_bits {
                        best_bits = cur_bits;
                        best_out = clusters[(j as (usize))];
                    }
                }
                j = j.wrapping_add(1 as (usize));
            }
            symbols[(i as (usize)) ]= best_out;
        }
        i = i.wrapping_add(1 as (usize));
    }
    i = 0usize;
    while i < num_clusters {
        {
            HistogramClearLiteral(
                &mut *out[(
                          clusters[(i as (usize)) ]as (usize)
                      ) ..]
            );
        }
        i = i.wrapping_add(1 as (usize));
    }
    i = 0usize;
    while i < in_size {
        {
            HistogramAddHistogramLiteral(
                &mut *out[(
                          symbols[(i as (usize)) ]as (usize)
                      ) ..],
                &inp[(i as (usize)) ]
            );
        }
        i = i.wrapping_add(1 as (usize));
    }
}



pub struct MemoryManager {
    pub alloc_func : fn(*mut ::std::os::raw::c_void, usize) -> *mut ::std::os::raw::c_void,
    pub free_func : fn(*mut ::std::os::raw::c_void, *mut ::std::os::raw::c_void),
    pub opaque : *mut ::std::os::raw::c_void,
}


pub fn BrotliHistogramReindexLiteral(
    mut m : &mut [MemoryManager],
    mut out : &mut [HistogramLiteral],
    mut symbols : &mut [u32],
    mut length : usize
) -> usize {
    static kInvalidIndex : u32 = !(0u32);
    let mut new_index
        : *mut u32
        = if length != 0 {
              BrotliAllocate(
                  m,
                  length.wrapping_mul(::std::mem::size_of::<u32>())
              ) 
          } else {
              0i32  
          };
    let mut next_index : u32;
    let mut tmp : *mut HistogramLiteral;
    let mut i : usize;
    if !(0i32 == 0) {
        return 0usize;
    }
    i = 0usize;
    while i < length {
        {
            new_index[(i as (usize)) ]= kInvalidIndex;
        }
        i = i.wrapping_add(1 as (usize));
    }
    next_index = 0u32;
    i = 0usize;
    while i < length {
        {
            if *new_index[(
                    symbols[(i as (usize)) ]as (usize)
                ) ..]== kInvalidIndex {
                *new_index[(
                     symbols[(i as (usize)) ]as (usize)
                 ) ..]= next_index;
                next_index = next_index.wrapping_add(1 as (u32));
            }
        }
        i = i.wrapping_add(1 as (usize));
    }
    tmp = if next_index != 0 {
              BrotliAllocate(
                  m,
                  (next_index as (usize)).wrapping_mul(
                      ::std::mem::size_of::<HistogramLiteral>()
                  )
              ) 
          } else {
              0i32  
          };
    if !(0i32 == 0) {
        return 0usize;
    }
    next_index = 0u32;
    i = 0usize;
    while i < length {
        {
            if *new_index[(
                    symbols[(i as (usize)) ]as (usize)
                ) ..]== next_index {
                tmp[(next_index as (usize)) ]= *out[(
                                                          symbols[(i as (usize)) ]as (usize)
                                                      )..];
                next_index = next_index.wrapping_add(1 as (u32));
            }
            symbols[(i as (usize)) ]= *new_index[(
                                                 symbols[(i as (usize)) ]as (usize)
                                             )..];
        }
        i = i.wrapping_add(1 as (usize));
    }
    {
        BrotliFree(m,new_index );
        new_index = 0i32  ;
    }
    i = 0usize;
    while i < next_index as (usize) {
        {
            out[(i as (usize)) ]= tmp[(i as (usize))];
        }
        i = i.wrapping_add(1 as (usize));
    }
    {
        BrotliFree(m,tmp );
        tmp = 0i32  ;
    }
    next_index as (usize)
}

fn brotli_min_size_t(
    mut a : usize, mut b : usize
) -> usize {
    if a < b { a } else { b }
}


pub fn BrotliClusterHistogramsLiteral(
    mut m : &mut [MemoryManager],
    mut inp : & [HistogramLiteral],
    in_size : usize,
    mut max_histograms : usize,
    mut out : &mut [HistogramLiteral],
    mut out_size : &mut [usize],
    mut histogram_symbols : &mut [u32
]) {
    let mut cluster_size
        : *mut u32
        = if in_size != 0 {
              BrotliAllocate(
                  m,
                  in_size.wrapping_mul(::std::mem::size_of::<u32>())
              ) 
          } else {
              0i32  
          };
    let mut clusters
        : *mut u32
        = if in_size != 0 {
              BrotliAllocate(
                  m,
                  in_size.wrapping_mul(::std::mem::size_of::<u32>())
              ) 
          } else {
              0i32  
          };
    let mut num_clusters : usize = 0usize;
    let max_input_histograms : usize = 64usize;
    let mut pairs_capacity
        : usize
        = max_input_histograms.wrapping_mul(
              max_input_histograms
          ).wrapping_div(
              2usize
          );
    let mut pairs
        : *mut HistogramPair
        = if pairs_capacity.wrapping_add(1usize) != 0 {
              BrotliAllocate(
                  m,
                  pairs_capacity.wrapping_add(1usize).wrapping_mul(
                      ::std::mem::size_of::<HistogramPair>()
                  )
              ) 
          } else {
              0i32  
          };
    let mut i : usize;
    if !(0i32 == 0) {
        return;
    }
    i = 0usize;
    while i < in_size {
        {
            cluster_size[(i as (usize)) ]= 1u32;
        }
        i = i.wrapping_add(1 as (usize));
    }
    i = 0usize;
    while i < in_size {
        {
            out[(i as (usize)) ]= inp[(i as (usize))];
            (out[(
                  i as (usize)
              )]).bit_cost_ = BrotliPopulationCostLiteral(
                                 &inp[(i as (usize)) ]
                             );
            histogram_symbols[(i as (usize)) ]= i as (u32);
        }
        i = i.wrapping_add(1 as (usize));
    }
    i = 0usize;
    while i < in_size {
        {
            let mut num_to_combine
                : usize
                = brotli_min_size_t(in_size.wrapping_sub(i),max_input_histograms);
            let mut num_new_clusters : usize;
            let mut j : usize;
            j = 0usize;
            while j < num_to_combine {
                {
                    clusters[(
                         num_clusters.wrapping_add(j) as (usize)
                     ) ]= i.wrapping_add(j) as (u32);
                }
                j = j.wrapping_add(1 as (usize));
            }
            num_new_clusters = BrotliHistogramCombineLiteral(
                                   out,
                                   cluster_size,
                                   &mut histogram_symbols[(i as (usize)) ],
                                   &mut clusters[(num_clusters as (usize)) ],
                                   pairs,
                                   num_to_combine,
                                   num_to_combine,
                                   max_histograms,
                                   pairs_capacity
                               );
            num_clusters = num_clusters.wrapping_add(num_new_clusters);
        }
        i = i.wrapping_add(max_input_histograms);
    }
    {
        let mut max_num_pairs
            : usize
            = brotli_min_size_t(
                  (64usize).wrapping_mul(num_clusters),
                  num_clusters.wrapping_div(2usize).wrapping_mul(
                      num_clusters
                  )
              );
        {
            if pairs_capacity < max_num_pairs.wrapping_add(1usize) {
                let mut _new_size
                    : usize
                    = if pairs_capacity == 0usize {
                          max_num_pairs.wrapping_add(1usize)
                      } else {
                          pairs_capacity
                      };
                let mut new_array : *mut HistogramPair;
                while _new_size < max_num_pairs.wrapping_add(1usize) {
                    _new_size = _new_size.wrapping_mul(2usize);
                }
                new_array = if _new_size != 0 {
                                BrotliAllocate(
                                    m,
                                    _new_size.wrapping_mul(::std::mem::size_of::<HistogramPair>())
                                ) 
                            } else {
                                0i32  
                            };
                if !!(0i32 == 0) && (pairs_capacity != 0usize) {
                    memcpy(
                        new_array ,
                        pairs ,
                        pairs_capacity.wrapping_mul(::std::mem::size_of::<HistogramPair>())
                    );
                }
                {
                    BrotliFree(m,pairs );
                    pairs = 0i32  ;
                }
                pairs = new_array;
                pairs_capacity = _new_size;
            }
        }
        if !(0i32 == 0) {
            return;
        }
        num_clusters = BrotliHistogramCombineLiteral(
                           out,
                           cluster_size,
                           histogram_symbols,
                           clusters,
                           pairs,
                           num_clusters,
                           in_size,
                           max_histograms,
                           max_num_pairs
                       );
    }
    {
        BrotliFree(m,pairs );
        pairs = 0i32  ;
    }
    {
        BrotliFree(m,cluster_size );
        cluster_size = 0i32  ;
    }
    BrotliHistogramRemapLiteral(
        inp,
        in_size,
        clusters ,
        num_clusters,
        out,
        histogram_symbols
    );
    {
        BrotliFree(m,clusters );
        clusters = 0i32  ;
    }
    *out_size = BrotliHistogramReindexLiteral(
                    m,
                    out,
                    histogram_symbols,
                    in_size
                );
    if !(0i32 == 0) { }
}



pub struct HistogramCommand {
    pub data_ : [u32; 704],
    pub total_count_ : usize,
    pub bit_cost_ : f64,
}

fn HistogramAddHistogramCommand(
    mut xself : &mut HistogramCommand, mut v : & [HistogramCommand
]) {
    let mut i : usize;
    (*xself).total_count_ = (*xself).total_count_.wrapping_add(
                               (*v).total_count_
                           );
    i = 0usize;
    while i < 704usize {
        {
            let _rhs = (*v).data_[i];
            let _lhs = &mut (*xself).data_[i];
            *_lhs = (*_lhs).wrapping_add(_rhs);
        }
        i = i.wrapping_add(1 as (usize));
    }
}


pub fn BrotliCompareAndPushToQueueCommand(
    mut out : & [HistogramCommand],
    mut cluster_size : & [u32],
    mut idx1 : u32,
    mut idx2 : u32,
    mut max_num_pairs : usize,
    mut pairs : &mut [HistogramPair],
    mut num_pairs : &mut [usize
]) {
    let mut is_good_pair : i32 = 0i32;
    let mut p : HistogramPair;
    if idx1 == idx2 {
        return;
    }
    if idx2 < idx1 {
        let mut t : u32 = idx2;
        idx2 = idx1;
        idx1 = t;
    }
    p.idx1 = idx1;
    p.idx2 = idx2;
    p.cost_diff = 0.5f64 * ClusterCostDiff(
                               cluster_size[(idx1 as (usize)) ]as (usize),
                               cluster_size[(idx2 as (usize)) ]as (usize)
                           );
    p.cost_diff = p.cost_diff - (out[(
                                      idx1 as (usize)
                                  )]).bit_cost_;
    p.cost_diff = p.cost_diff - (out[(
                                      idx2 as (usize)
                                  )]).bit_cost_;
    if (out[(idx1 as (usize))]).total_count_ == 0usize {
        p.cost_combo = (out[(idx2 as (usize))]).bit_cost_;
        is_good_pair = 1i32;
    } else if (out[(
                    idx2 as (usize)
                )]).total_count_ == 0usize {
        p.cost_combo = (out[(idx1 as (usize))]).bit_cost_;
        is_good_pair = 1i32;
    } else {
        let mut threshold
            : f64
            = if *num_pairs == 0usize {
                  1e99f64
              } else {
                  brotli_max_double(
                      0.0f64,
                      (pairs[(0usize)]).cost_diff
                  )
              };
        let mut combo : HistogramCommand = out[(idx1 as (usize))];
        let mut cost_combo : f64;
        HistogramAddHistogramCommand(
            &mut combo ,
            &out[(idx2 as (usize)) ]
        );
        cost_combo = BrotliPopulationCostCommand(
                         &mut combo  
                     );
        if cost_combo < threshold - p.cost_diff {
            p.cost_combo = cost_combo;
            is_good_pair = 1i32;
        }
    }
    if is_good_pair != 0 {
        p.cost_diff = p.cost_diff + p.cost_combo;
        if *num_pairs > 0usize && (HistogramPairIsLess(
                                                &mut pairs[(
                                                          0usize
                                                      ) ] ,
                                                &mut p  
                                            ) != 0) {
            if *num_pairs < max_num_pairs {
                pairs[(*num_pairs as (usize)) ]= pairs[(
                                                            0usize
                                                        )];
                *num_pairs = (*num_pairs).wrapping_add(1 as (usize));
            }
            pairs[(0usize) ]= p;
        } else if *num_pairs < max_num_pairs {
            pairs[(*num_pairs as (usize)) ]= p;
            *num_pairs = (*num_pairs).wrapping_add(1 as (usize));
        }
    }
}


pub fn BrotliHistogramCombineCommand(
    mut out : &mut [HistogramCommand],
    mut cluster_size : &mut [u32],
    mut symbols : &mut [u32],
    mut clusters : &mut [u32],
    mut pairs : &mut [HistogramPair],
    mut num_clusters : usize,
    mut symbols_size : usize,
    mut max_clusters : usize,
    mut max_num_pairs : usize
) -> usize {
    let mut cost_diff_threshold : f64 = 0.0f64;
    let mut min_cluster_size : usize = 1usize;
    let mut num_pairs : usize = 0usize;
    {
        let mut idx1 : usize;
        idx1 = 0usize;
        while idx1 < num_clusters {
            {
                let mut idx2 : usize;
                idx2 = idx1.wrapping_add(1usize);
                while idx2 < num_clusters {
                    {
                        BrotliCompareAndPushToQueueCommand(
                            out ,
                            cluster_size ,
                            clusters[(idx1 as (usize))],
                            clusters[(idx2 as (usize))],
                            max_num_pairs,
                            &mut pairs[(0usize) ],
                            &mut num_pairs 
                        );
                    }
                    idx2 = idx2.wrapping_add(1 as (usize));
                }
            }
            idx1 = idx1.wrapping_add(1 as (usize));
        }
    }
    while num_clusters > min_cluster_size {
        let mut best_idx1 : u32;
        let mut best_idx2 : u32;
        let mut i : usize;
        if (pairs[(
                 0usize
             )]).cost_diff >= cost_diff_threshold {
            cost_diff_threshold = 1e99f64;
            min_cluster_size = max_clusters;
            {
                {
                    continue;
                }
            }
        }
        best_idx1 = (pairs[(0usize)]).idx1;
        best_idx2 = (pairs[(0usize)]).idx2;
        HistogramAddHistogramCommand(
            &mut out[(best_idx1 as (usize)) ],
            &mut out[(
                      best_idx2 as (usize)
                  ) ] 
        );
        (out[(best_idx1 as (usize))]).bit_cost_ = (pairs[(
                                                              0usize
                                                          )]).cost_combo;
        {
            let _rhs = cluster_size[(best_idx2 as (usize))];
            let _lhs = &mut cluster_size[(best_idx1 as (usize))];
            *_lhs = (*_lhs).wrapping_add(_rhs);
        }
        i = 0usize;
        while i < symbols_size {
            {
                if symbols[(i as (usize)) ]== best_idx2 {
                    symbols[(i as (usize)) ]= best_idx1;
                }
            }
            i = i.wrapping_add(1 as (usize));
        }
        i = 0usize;
        'break47: while i < num_clusters {
            {
                if clusters[(i as (usize)) ]== best_idx2 {
                    memmove(
                        &mut clusters[(
                                  i as (usize)
                              ) ] ,
                        &mut clusters[(
                                  i.wrapping_add(1usize) as (usize)
                              ) ] ,
                        num_clusters.wrapping_sub(i).wrapping_sub(
                            1usize
                        ).wrapping_mul(
                            ::std::mem::size_of::<u32>()
                        )
                    );
                    {
                        {
                            break 'break47;
                        }
                    }
                }
            }
            i = i.wrapping_add(1 as (usize));
        }
        num_clusters = num_clusters.wrapping_sub(1 as (usize));
        {
            let mut copy_to_idx : usize = 0usize;
            i = 0usize;
            while i < num_pairs {
                'continue50: loop {
                    {
                        let mut p
                            : *mut HistogramPair
                            = &mut pairs[(i as (usize)) ];
                        if (*p).idx1 == best_idx1 || (*p).idx2 == best_idx1 || (*p).idx1 == best_idx2 || (*p).idx2 == best_idx2 {
                            {
                                break 'continue50;
                            }
                        }
                        if HistogramPairIsLess(
                               &mut pairs[(
                                         0usize
                                     ) ] ,
                               p 
                           ) != 0 {
                            let mut front : HistogramPair = pairs[(0usize)];
                            pairs[(0usize) ]= *p;
                            pairs[(copy_to_idx as (usize)) ]= front;
                        } else {
                            pairs[(copy_to_idx as (usize)) ]= *p;
                        }
                        copy_to_idx = copy_to_idx.wrapping_add(1 as (usize));
                    }
                    break;
                }
                i = i.wrapping_add(1 as (usize));
            }
            num_pairs = copy_to_idx;
        }
        i = 0usize;
        while i < num_clusters {
            {
                BrotliCompareAndPushToQueueCommand(
                    out ,
                    cluster_size ,
                    best_idx1,
                    clusters[(i as (usize))],
                    max_num_pairs,
                    &mut pairs[(0usize) ],
                    &mut num_pairs 
                );
            }
            i = i.wrapping_add(1 as (usize));
        }
    }
    num_clusters
}


pub fn BrotliHistogramBitCostDistanceCommand(
    mut histogram : & [HistogramCommand],
    mut candidate : & [HistogramCommand
]) -> f64 {
    if (*histogram).total_count_ == 0usize {
        0.0f64
    } else {
        let mut tmp : HistogramCommand = *histogram;
        HistogramAddHistogramCommand(
            &mut tmp ,
            candidate
        );
        BrotliPopulationCostCommand(
            &mut tmp  
        ) - (*candidate).bit_cost_
    }
}

fn HistogramClearCommand(
    mut xself : &mut HistogramCommand
) {
    memset(
        (*xself).data_.as_mut_ptr() ,
        0i32,
        ::std::mem::size_of::<[u32; 704]>()
    );
    (*xself).total_count_ = 0usize;
    (*xself).bit_cost_ = 3.402e+38f64;
}


pub fn BrotliHistogramRemapCommand(
    mut inp : & [HistogramCommand],
    mut in_size : usize,
    mut clusters : & [u32],
    mut num_clusters : usize,
    mut out : &mut [HistogramCommand],
    mut symbols : &mut [u32
]) {
    let mut i : usize;
    i = 0usize;
    while i < in_size {
        {
            let mut best_out
                : u32
                = if i == 0usize {
                      symbols[(0usize) ]}else {
                      symbols[(i.wrapping_sub(1usize) as (usize))]};
            let mut best_bits
                : f64
                = BrotliHistogramBitCostDistanceCommand(
                      &inp[(i as (usize)) ],
                      &mut out[(
                                best_out as (usize)
                            ) ] 
                  );
            let mut j : usize;
            j = 0usize;
            while j < num_clusters {
                {
                    let cur_bits
                        : f64
                        = BrotliHistogramBitCostDistanceCommand(
                              &inp[(i as (usize)) ],
                              &mut *out[(
                                        clusters[(j as (usize)) ]as (usize)
                                    ) ..] 
                          );
                    if cur_bits < best_bits {
                        best_bits = cur_bits;
                        best_out = clusters[(j as (usize))];
                    }
                }
                j = j.wrapping_add(1 as (usize));
            }
            symbols[(i as (usize)) ]= best_out;
        }
        i = i.wrapping_add(1 as (usize));
    }
    i = 0usize;
    while i < num_clusters {
        {
            HistogramClearCommand(
                &mut *out[(
                          clusters[(i as (usize)) ]as (usize)
                      ) ..]
            );
        }
        i = i.wrapping_add(1 as (usize));
    }
    i = 0usize;
    while i < in_size {
        {
            HistogramAddHistogramCommand(
                &mut *out[(
                          symbols[(i as (usize)) ]as (usize)
                      ) ..],
                &inp[(i as (usize)) ]
            );
        }
        i = i.wrapping_add(1 as (usize));
    }
}


pub fn BrotliHistogramReindexCommand(
    mut m : &mut [MemoryManager],
    mut out : &mut [HistogramCommand],
    mut symbols : &mut [u32],
    mut length : usize
) -> usize {
    static kInvalidIndex : u32 = !(0u32);
    let mut new_index
        : *mut u32
        = if length != 0 {
              BrotliAllocate(
                  m,
                  length.wrapping_mul(::std::mem::size_of::<u32>())
              ) 
          } else {
              0i32  
          };
    let mut next_index : u32;
    let mut tmp : *mut HistogramCommand;
    let mut i : usize;
    if !(0i32 == 0) {
        return 0usize;
    }
    i = 0usize;
    while i < length {
        {
            new_index[(i as (usize)) ]= kInvalidIndex;
        }
        i = i.wrapping_add(1 as (usize));
    }
    next_index = 0u32;
    i = 0usize;
    while i < length {
        {
            if *new_index[(
                    symbols[(i as (usize)) ]as (usize)
                ) ..]== kInvalidIndex {
                *new_index[(
                     symbols[(i as (usize)) ]as (usize)
                 ) ..]= next_index;
                next_index = next_index.wrapping_add(1 as (u32));
            }
        }
        i = i.wrapping_add(1 as (usize));
    }
    tmp = if next_index != 0 {
              BrotliAllocate(
                  m,
                  (next_index as (usize)).wrapping_mul(
                      ::std::mem::size_of::<HistogramCommand>()
                  )
              ) 
          } else {
              0i32  
          };
    if !(0i32 == 0) {
        return 0usize;
    }
    next_index = 0u32;
    i = 0usize;
    while i < length {
        {
            if *new_index[(
                    symbols[(i as (usize)) ]as (usize)
                ) ..]== next_index {
                tmp[(next_index as (usize)) ]= *out[(
                                                          symbols[(i as (usize)) ]as (usize)
                                                      )..];
                next_index = next_index.wrapping_add(1 as (u32));
            }
            symbols[(i as (usize)) ]= *new_index[(
                                                 symbols[(i as (usize)) ]as (usize)
                                             )..];
        }
        i = i.wrapping_add(1 as (usize));
    }
    {
        BrotliFree(m,new_index );
        new_index = 0i32  ;
    }
    i = 0usize;
    while i < next_index as (usize) {
        {
            out[(i as (usize)) ]= tmp[(i as (usize))];
        }
        i = i.wrapping_add(1 as (usize));
    }
    {
        BrotliFree(m,tmp );
        tmp = 0i32  ;
    }
    next_index as (usize)
}


pub fn BrotliClusterHistogramsCommand(
    mut m : &mut [MemoryManager],
    mut inp : & [HistogramCommand],
    in_size : usize,
    mut max_histograms : usize,
    mut out : &mut [HistogramCommand],
    mut out_size : &mut [usize],
    mut histogram_symbols : &mut [u32
]) {
    let mut cluster_size
        : *mut u32
        = if in_size != 0 {
              BrotliAllocate(
                  m,
                  in_size.wrapping_mul(::std::mem::size_of::<u32>())
              ) 
          } else {
              0i32  
          };
    let mut clusters
        : *mut u32
        = if in_size != 0 {
              BrotliAllocate(
                  m,
                  in_size.wrapping_mul(::std::mem::size_of::<u32>())
              ) 
          } else {
              0i32  
          };
    let mut num_clusters : usize = 0usize;
    let max_input_histograms : usize = 64usize;
    let mut pairs_capacity
        : usize
        = max_input_histograms.wrapping_mul(
              max_input_histograms
          ).wrapping_div(
              2usize
          );
    let mut pairs
        : *mut HistogramPair
        = if pairs_capacity.wrapping_add(1usize) != 0 {
              BrotliAllocate(
                  m,
                  pairs_capacity.wrapping_add(1usize).wrapping_mul(
                      ::std::mem::size_of::<HistogramPair>()
                  )
              ) 
          } else {
              0i32  
          };
    let mut i : usize;
    if !(0i32 == 0) {
        return;
    }
    i = 0usize;
    while i < in_size {
        {
            cluster_size[(i as (usize)) ]= 1u32;
        }
        i = i.wrapping_add(1 as (usize));
    }
    i = 0usize;
    while i < in_size {
        {
            out[(i as (usize)) ]= inp[(i as (usize))];
            (out[(
                  i as (usize)
              )]).bit_cost_ = BrotliPopulationCostCommand(
                                 &inp[(i as (usize)) ]
                             );
            histogram_symbols[(i as (usize)) ]= i as (u32);
        }
        i = i.wrapping_add(1 as (usize));
    }
    i = 0usize;
    while i < in_size {
        {
            let mut num_to_combine
                : usize
                = brotli_min_size_t(in_size.wrapping_sub(i),max_input_histograms);
            let mut num_new_clusters : usize;
            let mut j : usize;
            j = 0usize;
            while j < num_to_combine {
                {
                    clusters[(
                         num_clusters.wrapping_add(j) as (usize)
                     ) ]= i.wrapping_add(j) as (u32);
                }
                j = j.wrapping_add(1 as (usize));
            }
            num_new_clusters = BrotliHistogramCombineCommand(
                                   out,
                                   cluster_size,
                                   &mut histogram_symbols[(i as (usize)) ],
                                   &mut clusters[(num_clusters as (usize)) ],
                                   pairs,
                                   num_to_combine,
                                   num_to_combine,
                                   max_histograms,
                                   pairs_capacity
                               );
            num_clusters = num_clusters.wrapping_add(num_new_clusters);
        }
        i = i.wrapping_add(max_input_histograms);
    }
    {
        let mut max_num_pairs
            : usize
            = brotli_min_size_t(
                  (64usize).wrapping_mul(num_clusters),
                  num_clusters.wrapping_div(2usize).wrapping_mul(
                      num_clusters
                  )
              );
        {
            if pairs_capacity < max_num_pairs.wrapping_add(1usize) {
                let mut _new_size
                    : usize
                    = if pairs_capacity == 0usize {
                          max_num_pairs.wrapping_add(1usize)
                      } else {
                          pairs_capacity
                      };
                let mut new_array : *mut HistogramPair;
                while _new_size < max_num_pairs.wrapping_add(1usize) {
                    _new_size = _new_size.wrapping_mul(2usize);
                }
                new_array = if _new_size != 0 {
                                BrotliAllocate(
                                    m,
                                    _new_size.wrapping_mul(::std::mem::size_of::<HistogramPair>())
                                ) 
                            } else {
                                0i32  
                            };
                if !!(0i32 == 0) && (pairs_capacity != 0usize) {
                    memcpy(
                        new_array ,
                        pairs ,
                        pairs_capacity.wrapping_mul(::std::mem::size_of::<HistogramPair>())
                    );
                }
                {
                    BrotliFree(m,pairs );
                    pairs = 0i32  ;
                }
                pairs = new_array;
                pairs_capacity = _new_size;
            }
        }
        if !(0i32 == 0) {
            return;
        }
        num_clusters = BrotliHistogramCombineCommand(
                           out,
                           cluster_size,
                           histogram_symbols,
                           clusters,
                           pairs,
                           num_clusters,
                           in_size,
                           max_histograms,
                           max_num_pairs
                       );
    }
    {
        BrotliFree(m,pairs );
        pairs = 0i32  ;
    }
    {
        BrotliFree(m,cluster_size );
        cluster_size = 0i32  ;
    }
    BrotliHistogramRemapCommand(
        inp,
        in_size,
        clusters ,
        num_clusters,
        out,
        histogram_symbols
    );
    {
        BrotliFree(m,clusters );
        clusters = 0i32  ;
    }
    *out_size = BrotliHistogramReindexCommand(
                    m,
                    out,
                    histogram_symbols,
                    in_size
                );
    if !(0i32 == 0) { }
}



pub struct HistogramDistance {
    pub data_ : [u32; 520],
    pub total_count_ : usize,
    pub bit_cost_ : f64,
}

fn HistogramAddHistogramDistance(
    mut xself : &mut HistogramDistance, mut v : & [HistogramDistance
]) {
    let mut i : usize;
    (*xself).total_count_ = (*xself).total_count_.wrapping_add(
                               (*v).total_count_
                           );
    i = 0usize;
    while i < 520usize {
        {
            let _rhs = (*v).data_[i];
            let _lhs = &mut (*xself).data_[i];
            *_lhs = (*_lhs).wrapping_add(_rhs);
        }
        i = i.wrapping_add(1 as (usize));
    }
}


pub fn BrotliCompareAndPushToQueueDistance(
    mut out : & [HistogramDistance],
    mut cluster_size : & [u32],
    mut idx1 : u32,
    mut idx2 : u32,
    mut max_num_pairs : usize,
    mut pairs : &mut [HistogramPair],
    mut num_pairs : &mut [usize
]) {
    let mut is_good_pair : i32 = 0i32;
    let mut p : HistogramPair;
    if idx1 == idx2 {
        return;
    }
    if idx2 < idx1 {
        let mut t : u32 = idx2;
        idx2 = idx1;
        idx1 = t;
    }
    p.idx1 = idx1;
    p.idx2 = idx2;
    p.cost_diff = 0.5f64 * ClusterCostDiff(
                               cluster_size[(idx1 as (usize)) ]as (usize),
                               cluster_size[(idx2 as (usize)) ]as (usize)
                           );
    p.cost_diff = p.cost_diff - (out[(
                                      idx1 as (usize)
                                  )]).bit_cost_;
    p.cost_diff = p.cost_diff - (out[(
                                      idx2 as (usize)
                                  )]).bit_cost_;
    if (out[(idx1 as (usize))]).total_count_ == 0usize {
        p.cost_combo = (out[(idx2 as (usize))]).bit_cost_;
        is_good_pair = 1i32;
    } else if (out[(
                    idx2 as (usize)
                )]).total_count_ == 0usize {
        p.cost_combo = (out[(idx1 as (usize))]).bit_cost_;
        is_good_pair = 1i32;
    } else {
        let mut threshold
            : f64
            = if *num_pairs == 0usize {
                  1e99f64
              } else {
                  brotli_max_double(
                      0.0f64,
                      (pairs[(0usize)]).cost_diff
                  )
              };
        let mut combo : HistogramDistance = out[(idx1 as (usize))];
        let mut cost_combo : f64;
        HistogramAddHistogramDistance(
            &mut combo ,
            &out[(idx2 as (usize)) ]
        );
        cost_combo = BrotliPopulationCostDistance(
                         &mut combo  
                     );
        if cost_combo < threshold - p.cost_diff {
            p.cost_combo = cost_combo;
            is_good_pair = 1i32;
        }
    }
    if is_good_pair != 0 {
        p.cost_diff = p.cost_diff + p.cost_combo;
        if *num_pairs > 0usize && (HistogramPairIsLess(
                                                &mut pairs[(
                                                          0usize
                                                      ) ] ,
                                                &mut p  
                                            ) != 0) {
            if *num_pairs < max_num_pairs {
                pairs[(*num_pairs as (usize)) ]= pairs[(
                                                            0usize
                                                        )];
                *num_pairs = (*num_pairs).wrapping_add(1 as (usize));
            }
            pairs[(0usize) ]= p;
        } else if *num_pairs < max_num_pairs {
            pairs[(*num_pairs as (usize)) ]= p;
            *num_pairs = (*num_pairs).wrapping_add(1 as (usize));
        }
    }
}


pub fn BrotliHistogramCombineDistance(
    mut out : &mut [HistogramDistance],
    mut cluster_size : &mut [u32],
    mut symbols : &mut [u32],
    mut clusters : &mut [u32],
    mut pairs : &mut [HistogramPair],
    mut num_clusters : usize,
    mut symbols_size : usize,
    mut max_clusters : usize,
    mut max_num_pairs : usize
) -> usize {
    let mut cost_diff_threshold : f64 = 0.0f64;
    let mut min_cluster_size : usize = 1usize;
    let mut num_pairs : usize = 0usize;
    {
        let mut idx1 : usize;
        idx1 = 0usize;
        while idx1 < num_clusters {
            {
                let mut idx2 : usize;
                idx2 = idx1.wrapping_add(1usize);
                while idx2 < num_clusters {
                    {
                        BrotliCompareAndPushToQueueDistance(
                            out ,
                            cluster_size ,
                            clusters[(idx1 as (usize))],
                            clusters[(idx2 as (usize))],
                            max_num_pairs,
                            &mut pairs[(0usize) ],
                            &mut num_pairs 
                        );
                    }
                    idx2 = idx2.wrapping_add(1 as (usize));
                }
            }
            idx1 = idx1.wrapping_add(1 as (usize));
        }
    }
    while num_clusters > min_cluster_size {
        let mut best_idx1 : u32;
        let mut best_idx2 : u32;
        let mut i : usize;
        if (pairs[(
                 0usize
             )]).cost_diff >= cost_diff_threshold {
            cost_diff_threshold = 1e99f64;
            min_cluster_size = max_clusters;
            {
                {
                    continue;
                }
            }
        }
        best_idx1 = (pairs[(0usize)]).idx1;
        best_idx2 = (pairs[(0usize)]).idx2;
        HistogramAddHistogramDistance(
            &mut out[(best_idx1 as (usize)) ],
            &mut out[(
                      best_idx2 as (usize)
                  ) ] 
        );
        (out[(best_idx1 as (usize))]).bit_cost_ = (pairs[(
                                                              0usize
                                                          )]).cost_combo;
        {
            let _rhs = cluster_size[(best_idx2 as (usize))];
            let _lhs = &mut cluster_size[(best_idx1 as (usize))];
            *_lhs = (*_lhs).wrapping_add(_rhs);
        }
        i = 0usize;
        while i < symbols_size {
            {
                if symbols[(i as (usize)) ]== best_idx2 {
                    symbols[(i as (usize)) ]= best_idx1;
                }
            }
            i = i.wrapping_add(1 as (usize));
        }
        i = 0usize;
        'break85: while i < num_clusters {
            {
                if clusters[(i as (usize)) ]== best_idx2 {
                    memmove(
                        &mut clusters[(
                                  i as (usize)
                              ) ] ,
                        &mut clusters[(
                                  i.wrapping_add(1usize) as (usize)
                              ) ] ,
                        num_clusters.wrapping_sub(i).wrapping_sub(
                            1usize
                        ).wrapping_mul(
                            ::std::mem::size_of::<u32>()
                        )
                    );
                    {
                        {
                            break 'break85;
                        }
                    }
                }
            }
            i = i.wrapping_add(1 as (usize));
        }
        num_clusters = num_clusters.wrapping_sub(1 as (usize));
        {
            let mut copy_to_idx : usize = 0usize;
            i = 0usize;
            while i < num_pairs {
                'continue88: loop {
                    {
                        let mut p
                            : *mut HistogramPair
                            = &mut pairs[(i as (usize)) ];
                        if (*p).idx1 == best_idx1 || (*p).idx2 == best_idx1 || (*p).idx1 == best_idx2 || (*p).idx2 == best_idx2 {
                            {
                                break 'continue88;
                            }
                        }
                        if HistogramPairIsLess(
                               &mut pairs[(
                                         0usize
                                     ) ] ,
                               p 
                           ) != 0 {
                            let mut front : HistogramPair = pairs[(0usize)];
                            pairs[(0usize) ]= *p;
                            pairs[(copy_to_idx as (usize)) ]= front;
                        } else {
                            pairs[(copy_to_idx as (usize)) ]= *p;
                        }
                        copy_to_idx = copy_to_idx.wrapping_add(1 as (usize));
                    }
                    break;
                }
                i = i.wrapping_add(1 as (usize));
            }
            num_pairs = copy_to_idx;
        }
        i = 0usize;
        while i < num_clusters {
            {
                BrotliCompareAndPushToQueueDistance(
                    out ,
                    cluster_size ,
                    best_idx1,
                    clusters[(i as (usize))],
                    max_num_pairs,
                    &mut pairs[(0usize) ],
                    &mut num_pairs 
                );
            }
            i = i.wrapping_add(1 as (usize));
        }
    }
    num_clusters
}


pub fn BrotliHistogramBitCostDistanceDistance(
    mut histogram : & [HistogramDistance],
    mut candidate : & [HistogramDistance
]) -> f64 {
    if (*histogram).total_count_ == 0usize {
        0.0f64
    } else {
        let mut tmp : HistogramDistance = *histogram;
        HistogramAddHistogramDistance(
            &mut tmp ,
            candidate
        );
        BrotliPopulationCostDistance(
            &mut tmp  
        ) - (*candidate).bit_cost_
    }
}

fn HistogramClearDistance(
    mut xself : &mut HistogramDistance
) {
    memset(
        (*xself).data_.as_mut_ptr() ,
        0i32,
        ::std::mem::size_of::<[u32; 520]>()
    );
    (*xself).total_count_ = 0usize;
    (*xself).bit_cost_ = 3.402e+38f64;
}


pub fn BrotliHistogramRemapDistance(
    mut inp : & [HistogramDistance],
    mut in_size : usize,
    mut clusters : & [u32],
    mut num_clusters : usize,
    mut out : &mut [HistogramDistance],
    mut symbols : &mut [u32
]) {
    let mut i : usize;
    i = 0usize;
    while i < in_size {
        {
            let mut best_out
                : u32
                = if i == 0usize {
                      symbols[(0usize) ]}else {
                      symbols[(i.wrapping_sub(1usize) as (usize))]};
            let mut best_bits
                : f64
                = BrotliHistogramBitCostDistanceDistance(
                      &inp[(i as (usize)) ],
                      &mut out[(
                                best_out as (usize)
                            ) ] 
                  );
            let mut j : usize;
            j = 0usize;
            while j < num_clusters {
                {
                    let cur_bits
                        : f64
                        = BrotliHistogramBitCostDistanceDistance(
                              &inp[(i as (usize)) ],
                              &mut *out[(
                                        clusters[(j as (usize)) ]as (usize)
                                    ) ..] 
                          );
                    if cur_bits < best_bits {
                        best_bits = cur_bits;
                        best_out = clusters[(j as (usize))];
                    }
                }
                j = j.wrapping_add(1 as (usize));
            }
            symbols[(i as (usize)) ]= best_out;
        }
        i = i.wrapping_add(1 as (usize));
    }
    i = 0usize;
    while i < num_clusters {
        {
            HistogramClearDistance(
                &mut *out[(
                          clusters[(i as (usize)) ]as (usize)
                      ) ..]
            );
        }
        i = i.wrapping_add(1 as (usize));
    }
    i = 0usize;
    while i < in_size {
        {
            HistogramAddHistogramDistance(
                &mut *out[(
                          symbols[(i as (usize)) ]as (usize)
                      ) ..],
                &inp[(i as (usize)) ]
            );
        }
        i = i.wrapping_add(1 as (usize));
    }
}


pub fn BrotliHistogramReindexDistance(
    mut m : &mut [MemoryManager],
    mut out : &mut [HistogramDistance],
    mut symbols : &mut [u32],
    mut length : usize
) -> usize {
    static kInvalidIndex : u32 = !(0u32);
    let mut new_index
        : *mut u32
        = if length != 0 {
              BrotliAllocate(
                  m,
                  length.wrapping_mul(::std::mem::size_of::<u32>())
              ) 
          } else {
              0i32  
          };
    let mut next_index : u32;
    let mut tmp : *mut HistogramDistance;
    let mut i : usize;
    if !(0i32 == 0) {
        return 0usize;
    }
    i = 0usize;
    while i < length {
        {
            new_index[(i as (usize)) ]= kInvalidIndex;
        }
        i = i.wrapping_add(1 as (usize));
    }
    next_index = 0u32;
    i = 0usize;
    while i < length {
        {
            if *new_index[(
                    symbols[(i as (usize)) ]as (usize)
                ) ..]== kInvalidIndex {
                *new_index[(
                     symbols[(i as (usize)) ]as (usize)
                 ) ..]= next_index;
                next_index = next_index.wrapping_add(1 as (u32));
            }
        }
        i = i.wrapping_add(1 as (usize));
    }
    tmp = if next_index != 0 {
              BrotliAllocate(
                  m,
                  (next_index as (usize)).wrapping_mul(
                      ::std::mem::size_of::<HistogramDistance>()
                  )
              ) 
          } else {
              0i32  
          };
    if !(0i32 == 0) {
        return 0usize;
    }
    next_index = 0u32;
    i = 0usize;
    while i < length {
        {
            if *new_index[(
                    symbols[(i as (usize)) ]as (usize)
                ) ..]== next_index {
                tmp[(next_index as (usize)) ]= *out[(
                                                          symbols[(i as (usize)) ]as (usize)
                                                      )..];
                next_index = next_index.wrapping_add(1 as (u32));
            }
            symbols[(i as (usize)) ]= *new_index[(
                                                 symbols[(i as (usize)) ]as (usize)
                                             )..];
        }
        i = i.wrapping_add(1 as (usize));
    }
    {
        BrotliFree(m,new_index );
        new_index = 0i32  ;
    }
    i = 0usize;
    while i < next_index as (usize) {
        {
            out[(i as (usize)) ]= tmp[(i as (usize))];
        }
        i = i.wrapping_add(1 as (usize));
    }
    {
        BrotliFree(m,tmp );
        tmp = 0i32  ;
    }
    next_index as (usize)
}


pub fn BrotliClusterHistogramsDistance(
    mut m : &mut [MemoryManager],
    mut inp : & [HistogramDistance],
    in_size : usize,
    mut max_histograms : usize,
    mut out : &mut [HistogramDistance],
    mut out_size : &mut [usize],
    mut histogram_symbols : &mut [u32
]) {
    let mut cluster_size
        : *mut u32
        = if in_size != 0 {
              BrotliAllocate(
                  m,
                  in_size.wrapping_mul(::std::mem::size_of::<u32>())
              ) 
          } else {
              0i32  
          };
    let mut clusters
        : *mut u32
        = if in_size != 0 {
              BrotliAllocate(
                  m,
                  in_size.wrapping_mul(::std::mem::size_of::<u32>())
              ) 
          } else {
              0i32  
          };
    let mut num_clusters : usize = 0usize;
    let max_input_histograms : usize = 64usize;
    let mut pairs_capacity
        : usize
        = max_input_histograms.wrapping_mul(
              max_input_histograms
          ).wrapping_div(
              2usize
          );
    let mut pairs
        : *mut HistogramPair
        = if pairs_capacity.wrapping_add(1usize) != 0 {
              BrotliAllocate(
                  m,
                  pairs_capacity.wrapping_add(1usize).wrapping_mul(
                      ::std::mem::size_of::<HistogramPair>()
                  )
              ) 
          } else {
              0i32  
          };
    let mut i : usize;
    if !(0i32 == 0) {
        return;
    }
    i = 0usize;
    while i < in_size {
        {
            cluster_size[(i as (usize)) ]= 1u32;
        }
        i = i.wrapping_add(1 as (usize));
    }
    i = 0usize;
    while i < in_size {
        {
            out[(i as (usize)) ]= inp[(i as (usize))];
            (out[(
                  i as (usize)
              )]).bit_cost_ = BrotliPopulationCostDistance(
                                 &inp[(i as (usize)) ]
                             );
            histogram_symbols[(i as (usize)) ]= i as (u32);
        }
        i = i.wrapping_add(1 as (usize));
    }
    i = 0usize;
    while i < in_size {
        {
            let mut num_to_combine
                : usize
                = brotli_min_size_t(in_size.wrapping_sub(i),max_input_histograms);
            let mut num_new_clusters : usize;
            let mut j : usize;
            j = 0usize;
            while j < num_to_combine {
                {
                    clusters[(
                         num_clusters.wrapping_add(j) as (usize)
                     ) ]= i.wrapping_add(j) as (u32);
                }
                j = j.wrapping_add(1 as (usize));
            }
            num_new_clusters = BrotliHistogramCombineDistance(
                                   out,
                                   cluster_size,
                                   &mut histogram_symbols[(i as (usize)) ],
                                   &mut clusters[(num_clusters as (usize)) ],
                                   pairs,
                                   num_to_combine,
                                   num_to_combine,
                                   max_histograms,
                                   pairs_capacity
                               );
            num_clusters = num_clusters.wrapping_add(num_new_clusters);
        }
        i = i.wrapping_add(max_input_histograms);
    }
    {
        let mut max_num_pairs
            : usize
            = brotli_min_size_t(
                  (64usize).wrapping_mul(num_clusters),
                  num_clusters.wrapping_div(2usize).wrapping_mul(
                      num_clusters
                  )
              );
        {
            if pairs_capacity < max_num_pairs.wrapping_add(1usize) {
                let mut _new_size
                    : usize
                    = if pairs_capacity == 0usize {
                          max_num_pairs.wrapping_add(1usize)
                      } else {
                          pairs_capacity
                      };
                let mut new_array : *mut HistogramPair;
                while _new_size < max_num_pairs.wrapping_add(1usize) {
                    _new_size = _new_size.wrapping_mul(2usize);
                }
                new_array = if _new_size != 0 {
                                BrotliAllocate(
                                    m,
                                    _new_size.wrapping_mul(::std::mem::size_of::<HistogramPair>())
                                ) 
                            } else {
                                0i32  
                            };
                if !!(0i32 == 0) && (pairs_capacity != 0usize) {
                    memcpy(
                        new_array ,
                        pairs ,
                        pairs_capacity.wrapping_mul(::std::mem::size_of::<HistogramPair>())
                    );
                }
                {
                    BrotliFree(m,pairs );
                    pairs = 0i32  ;
                }
                pairs = new_array;
                pairs_capacity = _new_size;
            }
        }
        if !(0i32 == 0) {
            return;
        }
        num_clusters = BrotliHistogramCombineDistance(
                           out,
                           cluster_size,
                           histogram_symbols,
                           clusters,
                           pairs,
                           num_clusters,
                           in_size,
                           max_histograms,
                           max_num_pairs
                       );
    }
    {
        BrotliFree(m,pairs );
        pairs = 0i32  ;
    }
    {
        BrotliFree(m,cluster_size );
        cluster_size = 0i32  ;
    }
    BrotliHistogramRemapDistance(
        inp,
        in_size,
        clusters ,
        num_clusters,
        out,
        histogram_symbols
    );
    {
        BrotliFree(m,clusters );
        clusters = 0i32  ;
    }
    *out_size = BrotliHistogramReindexDistance(
                    m,
                    out,
                    histogram_symbols,
                    in_size
                );
    if !(0i32 == 0) { }
}
